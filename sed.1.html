<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='content-type' value='text/html;charset=utf8'>
  <meta name='generator' value='Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)'>
  <title>sed(1)</title>
  <style type='text/css' media='all'>
  /* style: man */
  body#manpage {margin:0}
  .mp {max-width:100ex;padding:0 9ex 1ex 4ex}
  .mp p,.mp pre,.mp ul,.mp ol,.mp dl {margin:0 0 20px 0}
  .mp h2 {margin:10px 0 0 0}
  .mp > p,.mp > pre,.mp > ul,.mp > ol,.mp > dl {margin-left:8ex}
  .mp h3 {margin:0 0 0 4ex}
  .mp dt {margin:0;clear:left}
  .mp dt.flush {float:left;width:8ex}
  .mp dd {margin:0 0 0 9ex}
  .mp h1,.mp h2,.mp h3,.mp h4 {clear:left}
  .mp pre {margin-bottom:20px}
  .mp pre+h2,.mp pre+h3 {margin-top:22px}
  .mp h2+pre,.mp h3+pre {margin-top:5px}
  .mp img {display:block;margin:auto}
  .mp h1.man-title {display:none}
  .mp,.mp code,.mp pre,.mp tt,.mp kbd,.mp samp,.mp h3,.mp h4 {font-family:monospace;font-size:14px;line-height:1.42857142857143}
  .mp h2 {font-size:16px;line-height:1.25}
  .mp h1 {font-size:20px;line-height:2}
  .mp {text-align:justify;background:#fff}
  .mp,.mp code,.mp pre,.mp pre code,.mp tt,.mp kbd,.mp samp {color:#131211}
  .mp h1,.mp h2,.mp h3,.mp h4 {color:#030201}
  .mp u {text-decoration:underline}
  .mp code,.mp strong,.mp b {font-weight:bold;color:#131211}
  .mp em,.mp var {font-style:italic;color:#232221;text-decoration:none}
  .mp a,.mp a:link,.mp a:hover,.mp a code,.mp a pre,.mp a tt,.mp a kbd,.mp a samp {color:#0000ff}
  .mp b.man-ref {font-weight:normal;color:#434241}
  .mp pre {padding:0 4ex}
  .mp pre code {font-weight:normal;color:#434241}
  .mp h2+pre,h3+pre {padding-left:0}
  ol.man-decor,ol.man-decor li {margin:3px 0 10px 0;padding:0;float:left;width:33%;list-style-type:none;text-transform:uppercase;color:#999;letter-spacing:1px}
  ol.man-decor {width:100%}
  ol.man-decor li.tl {text-align:left}
  ol.man-decor li.tc {text-align:center;letter-spacing:4px}
  ol.man-decor li.tr {text-align:right;float:right}
  </style>
</head>
<!--
  The following styles are deprecated and will be removed at some point:
  div#man, div#man ol.man, div#man ol.head, div#man ol.man.

  The .man-page, .man-decor, .man-head, .man-foot, .man-title, and
  .man-navigation should be used instead.
-->
<body id='manpage'>
  <div class='mp' id='man'>

  <div class='man-navigation' style='display:none'>
    <a href="#NAME">NAME</a>
    <a href="#DESCRIPTION">DESCRIPTION</a>
    <a href="#There-are-four-parts-to-this-substitute-command-">There are four parts to this substitute command:</a>
    <a href="#The-slash-as-a-delimiter">The slash as a delimiter</a>
    <a href="#Using-as-the-matched-string">Using &amp; as the matched string</a>
    <a href="#Using-1-to-keep-part-of-the-pattern">Using \1 to keep part of the pattern</a>
    <a href="#-g-Global-replacement">/g - Global replacement</a>
    <a href="#Write-to-a-file-with-w-filename">Write to a file with /w filename</a>
    <a href="#Combining-substitution-flags">Combining substitution flags</a>
    <a href="#Arguments-and-invocation-of-sed">Arguments and invocation of sed</a>
    <a href="#Filenames-on-the-command-line">Filenames on the command line</a>
    <a href="#sed-comment-This-script-changes-lower-case-vowels-to-upper-case">sed comment - This script changes lower case vowels to upper case</a>
    <a href="#sed-in-shell-script">sed in shell script</a>
    <a href="#Quoting-multiple-sed-lines-in-the-Bourne-shell">Quoting multiple sed lines in the Bourne shell</a>
    <a href="#A-sed-interpreter-script">A sed interpreter script</a>
    <a href="#Passing-arguments-into-a-sed-script">Passing arguments into a sed script</a>
    <a href="#Using-sed-in-a-shell-here-is-document">Using sed in a shell here-is document</a>
    <a href="#Addresses-and-Ranges-of-Text">Addresses and Ranges of Text</a>
    <a href="#Restricting-to-a-line-number">Restricting to a line number</a>
    <a href="#Patterns">Patterns</a>
    <a href="#Ranges-by-line-number">Ranges by line number</a>
    <a href="#Ranges-by-patterns">Ranges by patterns</a>
    <a href="#Delete-with-d">Delete with d</a>
    <a href="#Relationships-between-d-p-and-">Relationships between d, p, and !</a>
    <a href="#The-q-or-quit-command">The q or quit command</a>
    <a href="#Grouping-with-and-">Grouping with { and }</a>
    <a href="#Writing-a-file-with-the-w-command">Writing a file with the 'w' command</a>
    <a href="#Reading-in-a-file-with-the-r-command">Reading in a file with the 'r' command</a>
    <a href="#SunOS-and-the-Comment-Command">SunOS and the # Comment Command</a>
    <a href="#Adding-Changing-Inserting-new-lines">Adding, Changing, Inserting new lines</a>
    <a href="#Insert-a-line-with-i-">Insert a line with 'i'</a>
    <a href="#Change-a-line-with-c-">Change a line with 'c'</a>
    <a href="#Leading-tabs-and-spaces-in-a-sed-script">Leading tabs and spaces in a sed script</a>
    <a href="#Adding-more-than-one-line">Adding more than one line</a>
    <a href="#Adding-lines-and-the-pattern-space">Adding lines and the pattern space</a>
    <a href="#Address-ranges-and-the-above-commands">Address ranges and the above commands</a>
    <a href="#Multi-Line-Patterns">Multi-Line Patterns</a>
    <a href="#Displaying-control-characters-with-a-l">Displaying control characters with a l</a>
    <a href="#Working-with-Multiple-Lines">Working with Multiple Lines</a>
    <a href="#Yeah-That-s-the-ticket-Or-use-the-C-shell-and-really-confuse-him-">Yeah. That's the ticket. Or use the C shell and really confuse him!</a>
    <a href="#The-Hold-Buffer">The Hold Buffer</a>
    <a href="#Exchange-with-x">Exchange with x</a>
    <a href="#Get-with-g-or-G">Get with g or G</a>
    <a href="#Flow-Control">Flow Control</a>
    <a href="#Testing-with-t">Testing with t</a>
    <a href="#An-alternate-way-of-adding-comments">An alternate way of adding comments</a>
    <a href="#The-poorly-documented-">The poorly documented ;</a>
    <a href="#Passing-regular-expressions-as-arguments">Passing regular expressions as arguments</a>
    <a href="#Command-Summary">Command Summary</a>
    <a href="#LINKS">LINKS</a>
  </div>

  <ol class='man-decor man-head man head'>
    <li class='tl'>sed(1)</li>
    <li class='tc'></li>
    <li class='tr'>sed(1)</li>
  </ol>

  <h2 id="NAME">NAME</h2>
<p class="man-name">
  <code>sed</code>
</p>
<p><a class="man-ref" href="sed.1.html">sed<span class="s">(1)</span></a> -- bash</p>

<h2 id="DESCRIPTION">DESCRIPTION</h2>

<pre><code>sed s/day/night/ &lt;old >new
</code></pre>

<p>Or another way (for Unix beginners),</p>

<pre><code>sed s/day/night/ old &gt;new
</code></pre>

<p>and for those who want to test this:</p>

<pre><code>echo day | sed s/day/night/
</code></pre>

<p>This will output "night".</p>

<p>I didn't put quotes around the argument because this example didn't need
them. If you read my earlier tutorial on quotes, you would understand
why it doesn't need quotes. However, I recommend you do use quotes. If
you have meta-characters in the command, quotes are necessary. And if
you aren't sure, it's a good habit, and I will henceforth quote future
examples to emphasize the "best practice." Using the strong (single
quote) character, that would be:</p>

<pre><code>sed 's/day/night/' &lt;old >new
</code></pre>

<h2 id="There-are-four-parts-to-this-substitute-command-">There are four parts to this substitute command:</h2>

<p><code>s</code>         Substitute command
<code>/../../</code>     Delimiter
<code>day</code>         Regular Expression Pattern Search Pattern
<code>night</code>     Replacement string</p>

<p>The search pattern is on the left hand side and the replacement string
is on the right hand side.</p>

<h2 id="The-slash-as-a-delimiter">The slash as a delimiter</h2>

<pre><code>sed 's/\/usr\/local\/bin/\/common\/bin/' &lt;old >new
</code></pre>

<p>Gulp. Some call this a 'Picket Fence' and it's ugly. It is easier to
read if you use an underline instead of a slash as a delimiter:</p>

<pre><code>sed 's_/usr/local/bin_/common/bin_' &lt;old >new
</code></pre>

<p>Some people use colons:</p>

<pre><code>sed 's:/usr/local/bin:/common/bin:' &lt;old >new
</code></pre>

<p>Others use the "|" character.</p>

<pre><code>sed 's|/usr/local/bin|/common/bin|' &lt;old >new
</code></pre>

<h2 id="Using-as-the-matched-string">Using &amp; as the matched string</h2>

<p>Sometimes you want to search for a pattern and add some characters, like
parenthesis, around or near the pattern you found. It is easy to do this
if you are looking for a particular string:</p>

<pre><code>sed 's/abc/(abc)/' &lt;old >new
</code></pre>

<p>This won't work if you don't know exactly what you will find. How can
you put the string you found in the replacement string if you don't know
what it is?</p>

<p>The solution requires the special character "&amp;." It corresponds to the
pattern found.</p>

<pre><code>sed 's/[a-z]*/(&amp;)/' &lt;old >new
</code></pre>

<p>You can have any number of "&amp;" in the replacement string. You could also
double a pattern, e.g. the first number of a line:</p>

<pre><code>% echo "123 abc" | sed 's/[0-9]*/&amp; &amp;/'
123 123 abc
</code></pre>

<p>Let me slightly amend this example. Sed will match the first string, and
make it as greedy as possible. The first match for '[0-9]*' is the first
character on the line, as this matches zero of more numbers. So if the
input was "abc 123" the output would be unchanged (well, except for a
space before the letters). A better way to duplicate the number is to
make sure it matches a number:</p>

<pre><code>% echo "123 abc" | sed 's/[0-9][0-9]*/&amp; &amp;/'
123 123 abc
</code></pre>

<p>The string "abc" is unchanged, because it was not matched by the regular
expression. If you wanted to eliminate "abc" from the output, you must
expand the the regular expression to match the rest of the line and
explicitly exclude part of the expression using "(", ")" and "\1", which
is the next topic.</p>

<h2 id="Using-1-to-keep-part-of-the-pattern">Using \1 to keep part of the pattern</h2>

<p>I have already described the use of "(" ")" and "1" in my tutorial on
regular expressions. To review, the escaped parentheses (that is,
parentheses with backslashes before them) remember portions of the
regular expression. You can use this to exclude part of the regular
expression. The "\1" is the first remembered pattern, and the "\2" is
the second remembered pattern. Sed has up to nine remembered patterns.</p>

<p>If you wanted to keep the first word of a line, and delete the rest of
the line, mark the important part with the parenthesis:</p>

<pre><code>sed 's/\([a-z]*\).*/\1/'
</code></pre>

<p>I should elaborate on this. Regular exprssions are greedy, and try to
match as much as possible. "[a-z]<em>" matches zero or more lower case
letters, and tries to be as big as possible. The ".</em>" matches zero or
more characters after the first match. Since the first one grabs all of
the lower case letters, the second matches anything else. Therefore if
you type</p>

<pre><code>echo abcd123 | sed 's/\([a-z]*\).*/\1/'
</code></pre>

<p>This will output "abcd" and delete the numbers.</p>

<p>If you want to switch two words around, you can remember two patterns
and change the order</p>

<pre><code>sed 's/\([a-z]*\) \([a-z]*\)/\2 \1/'
</code></pre>

<p>Note the space between the two remembered patterns. This is used to make
sure two words are found. However, this will do nothing if a single word
is found, or any lines with no letters. You may want to insist that
words have at least one letter by using</p>

<p>sed 's/([a-z][a-z]<em>) ([a-z][a-z]</em>)/\2 \1/'</p>

<p>The "\1" doesn't have to be in the replacement string (in the right hand
side). It can be in the pattern you are searching for (in the left hand
side). If you want to eliminate duplicated words, you can try:</p>

<p>sed 's/([a-z]*) \1/\1/'
If you want to detect duplicated words, you can use</p>

<p>sed -n '/([a-z][a-z]*) \1/p'
This, when used as a filter, will print liens with duplicated words.</p>

<p>The numeric value can have up to nine values: "\1" thru "\9." If you wanted to reverse the first three characters on a line, you can use</p>

<pre><code>sed 's/^\(.\)\(.\)\(.\)/\3\2\1/'
</code></pre>

<h2 id="-g-Global-replacement">/g - Global replacement</h2>

<p>If you want it to make changes for every word, add a "g" after the last delimiter and use the work-around:</p>

<pre><code>sed 's/[^ ][^ ]*/(&amp;)/g' &lt;old >new
</code></pre>

<p>Is sed recursive?</p>

<pre><code>sed 's/loop/loop the loop/g' &lt;old >new
</code></pre>

<p>This will not cause an infinite loop. If a second "s" command is
executed, it could modify the results of a previous command. I will show
you how to execute multiple commands later.</p>

<pre><code>/1, /2, etc. Specifying which occurrence
</code></pre>

<p>With no flags, the first pattern is changed. With the "g" option, all
patterns are changed. If you want to modify a particular pattern that is
not the first one on the line, you could use "(" and ")" to mark each
pattern, and use "\1" to put the first pattern back unchanged. This next
example keeps the first word on the line but deletes the second:</p>

<p>sed 's/([a-zA-Z]<em>) ([a-zA-Z]</em>) /\1 /' <var>old </var>new</p>

<p>Yuck. There is an easier way to do this. You can add a number after the
substitution command to indicate you only want to match that particular
pattern. Example:</p>

<pre><code>sed 's/[a-zA-Z]* //2' &lt;old >new
</code></pre>

<p>You can combine a number with the g (global) flag. For instance, if you
want to leave the first world alone alone, but change the second, third,
etc. to DELETED, use /2g:</p>

<pre><code>sed 's/[a-zA-Z]* /DELETED /2g' &lt;old >new
</code></pre>

<p>Don't get /2 and \2 confused. The /2 is used at the end. \2 is used in
inside the replacement field.</p>

<p>Note the space after the "*" character. Without the space, sed will run
a long, long time. (Note: this bug is probably fixed by now.) This is
because the number flag and the "g" flag have the same bug. You should
also be able to use the pattern</p>

<pre><code>sed 's/[^ ]*//2' &lt;old >new
</code></pre>

<p>but this also eats CPU. If this works on your computer, and it does on
some Unix systems, you could remove the encrypted password from the
password file:</p>

<pre><code>sed 's/[^:]*//2' &lt;/etc/passwd &gt;/etc/password.new
</code></pre>

<p>But this didn't work for me the time I wrote thise. Using "[<sup>:][<sup>:]*"</sup></sup> as
a work-around doesn't help because it won't match an non-existent
password, and instead delete the third field, which is the user ID!
Instead you have to use the ugly parenthesis:</p>

<pre><code>sed 's/^\([^:]*\):[^:]:/\1::/'  &lt;/etc/passwd &gt;/etc/password.new
</code></pre>

<p>You could also add a character to the first pattern so that it no longer
matches the null pattern:</p>

<pre><code>sed 's/[^:]*:/:/2'  &lt;/etc/passwd &gt;/etc/password.new
</code></pre>

<p>The number flag is not restricted to a single digit. It can be any
number from 1 to 512. If you wanted to add a colon after the 80th
character in each line, you could type:</p>

<pre><code>sed 's/./&amp;:/80' &lt;file >new
</code></pre>

<p>You can also do it the hard way by using 80 dots:</p>

<pre><code>sed 's/^....................................................... \
........................./&amp;:/' &lt;file >new
/p - print
</code></pre>

<p>By default, sed prints every line. If it makes a substitution, the new
text is printed instead of the old one. If you use an optional argument
to sed, "sed -n," it will not, by default, print any new lines. I'll
cover this and other options later. When the "-n" option is used, the
"p" flag will cause the modified line to be printed. Here is one way to
duplicate the function of grep with sed:</p>

<pre><code>sed -n 's/pattern/&amp;/p' &lt;file
</code></pre>

<h2 id="Write-to-a-file-with-w-filename">Write to a file with /w filename</h2>

<p>There is one more flag that can follow the third delimiter. With it, you
can specify a file that will receive the modified data. An example is
the following, which will write all lines that start with an even
number, followed by a space, to the file even:</p>

<pre><code>sed -n 's/^[0-9]*[02468] /&amp;/w even' &lt;file
</code></pre>

<h2 id="Combining-substitution-flags">Combining substitution flags</h2>

<p>You can combine flags when it makes sense. Also "w" has to be the last
flag. For example the following command works:</p>

<pre><code>sed -n 's/a/A/2pw /tmp/file' &lt;old >new
</code></pre>

<h2 id="Arguments-and-invocation-of-sed">Arguments and invocation of sed</h2>

<pre><code>sed 's/BEGIN/begin/' &lt;old | sed 's/END/end/' &gt;new
</code></pre>

<p>This used two processes instead of one. A sed guru never uses two processes when one can do.</p>

<p>Multiple commands with -e command</p>

<p>One method of combining multiple commands is to use a -e before each command:</p>

<pre><code>sed -e 's/a/A/' -e 's/b/B/' &lt;old >new
</code></pre>

<p>A "-e" isn't needed in the earlier examples because sed knows that there
must always be one command. If you give sed one argument, it must be a
command, and sed will edit the data read from standard input.</p>

<h2 id="Filenames-on-the-command-line">Filenames on the command line</h2>

<pre><code>sed 's/^#.*//'  f1 f2 f3 | grep -v '^$' | wc -l
</code></pre>

<p>The sed substitute command changes every line that starts with a "#"
into a blank line. Grep was used to filter out empty lines. Wc counts
the number of lines left. Sed has more commands that make grep
unnecessary. But I will cover that later.</p>

<p>Of course you could write the last example using the "-e" option:</p>

<pre><code>sed -e 's/^#.*//'  f1 f2 f3 | grep -v '^$' | wc -l
</code></pre>

<p>There are two other options to sed.</p>

<pre><code>sed -n: no printing
</code></pre>

<p>The "-n" option will not print anything unless an explicit request to
print is found. I mentioned the "/p" flag to the substitute command as
one way to turn printing back on. Let me clarify this. The command</p>

<pre><code>sed  's/PATTERN/&amp;/p' file
</code></pre>

<p>acts like the cat program if PATTERN is not in the file: e.g. nothing is
changed. If PATTERN is in the file, then each line that has this is
printed twice. Add the "-n" option and the example acts like grep:</p>

<pre><code>sed -n 's/PATTERN/&amp;/p' file
</code></pre>

<p>Nothing is printed, except those lines with PATTERN included.</p>

<pre><code>sed -f scriptname
</code></pre>

<p>If you have a large number of sed commands, you can put them into a file and use</p>

<pre><code>sed -f sedscript &lt;old >new
</code></pre>

<h2 id="sed-comment-This-script-changes-lower-case-vowels-to-upper-case">sed comment - This script changes lower case vowels to upper case</h2>

<pre><code>s/a/A/g
s/e/E/g
s/i/I/g
s/o/O/g
s/u/U/g
</code></pre>

<h2 id="sed-in-shell-script">sed in shell script</h2>

<p>If you have many commands and they won't fit neatly on one line, you can
break up the line using a backslash:</p>

<pre><code>sed -e 's/a/A/g' \
    -e 's/e/E/g' \
    -e 's/i/I/g' \
    -e 's/o/O/g' \
    -e 's/u/U/g'  &lt;old >new
</code></pre>

<h2 id="Quoting-multiple-sed-lines-in-the-Bourne-shell">Quoting multiple sed lines in the Bourne shell</h2>

<p>The Bourne shell makes this easier as a quote can cover several lines:</p>

<pre><code>#!/bin/sh
sed '
s/a/A/g
s/e/E/g
s/i/I/g
s/o/O/g
s/u/U/g'  &lt;old >new
</code></pre>

<h2 id="A-sed-interpreter-script">A sed interpreter script</h2>

<p>Another way of executing sed is to use an interpreter script. Create a
file that contains:</p>

<pre><code>#!/bin/sed -f
s/a/A/g
s/e/E/g
s/i/I/g
s/o/O/g
s/u/U/g
</code></pre>

<p>Sed comments are lines where the first non-white character is a "#." On
many systems, sed can have only one comment, and it must be the first
line of the script. On the Sun (1988 when I wrote this), you can have
several comment lines anywhere in the script. Modern versions of Sed
support this. If the first line contains exactly "#n" then this does the
same thing as the "-n" option: turning off printing by default. This
could not done with a sed interpreter script, because the first line
must start with "#!/bin/sed -f" as I think "#!/bin/sed -nf" generated an
error. It works as I write this update in 2008. Note that "#!/bin/sed
-fn" does not work because sed thinks the filename of the script is
"n". However,</p>

<pre><code>"#!/bin/sed -nf"
</code></pre>

<p>does work.</p>

<h2 id="Passing-arguments-into-a-sed-script">Passing arguments into a sed script</h2>

<p>Passing a word into a shell script that calls sed is easy if you
remembered my tutorial on the Unix quoting mechanism. To review, you use
the single quotes to turn quoting on and off. A simple shell script that
uses sed to emulate grep is:</p>

<pre><code>#!/bin/sh
sed -n 's/'$1'/&amp;/p'
</code></pre>

<p>However - there is a problem with this script. If you have a space as an
argument, the script would cause a syntax error A better version would
protect from this happening:</p>

<pre><code>#!/bin/sh
sed -n 's/'"$1"'/&amp;/p'
</code></pre>

<p>If this was stored in a file called sedgrep, you could type</p>

<pre><code>sedgrep '[A-Z][A-Z]' &lt;file
</code></pre>

<p>This would allow sed to act as the grep command.</p>

<h2 id="Using-sed-in-a-shell-here-is-document">Using sed in a shell here-is document</h2>

<p>You can use sed to prompt the user for some parameters and then create a
file with those parameters filled in. You could create a file with dummy
values placed inside it, and use sed to change those dummy values. A
simpler way is to use the "here is" document, which uses part of the
shell script as if it were standard input:</p>

<pre><code>#!/bin/sh
echo -n 'what is the value? '
read value
sed  's/XXX/'$value'/' &lt;&lt;EOF
The value is XXX
EOF
</code></pre>

<p>When executed, the script says:</p>

<p>what is the value?</p>

<p>If you type in "123," the next line will be:</p>

<p>The value is 123</p>

<p>I admit this is a contrived example. "Here is" documents can have values
evaluated without the use of sed. This example does the same thing:</p>

<pre><code>#!/bin/sh
echo -n 'what is the value? '
read value
cat &lt;&lt;EOF
The value is $value
EOF
</code></pre>

<p>However, combining "here is" documents with sed can be useful for some
complex cases.</p>

<p>Note that</p>

<pre><code>sed 's/XXX/'$value'/' &lt;&lt;EOF
</code></pre>

<p>will give a syntax error if the user types a space. Better form would be
to use</p>

<pre><code>sed 's/XXX/'"$value"'/' &lt;&lt;EOF
</code></pre>

<p>Multiple commands and order of execution</p>

<p>As we explore more of the commands of sed, the commands will become
complex, and the actual sequence can be confusing. It's really quite
simple. Each line is read in. Each command, in order specified by the
user, has a chance to operate on the input line. After the substitutions
are made, the next command has a chance to operate on the same line,
which may have been modified by earlier commands. If you ever have a
question, the best way to learn what will happen is to create a small
example. If a complex command doesn't work, make it simpler. If you are
having problems getting a complex script working, break it up into two
smaller scripts and pipe the two scripts together.</p>

<h2 id="Addresses-and-Ranges-of-Text">Addresses and Ranges of Text</h2>

<p>You have only learned one command, and you can see how powerful sed
is. However, all it is doing is a grep and substitute. That is, the
substitute command is treating each line by itself, without caring about
nearby lines. What would be useful is the ability to restrict the
operation to certain lines. Some useful restrictions might be:</p>

<ul>
<li>Specifying a line by its number.</li>
<li>Specifying a range of lines by number.</li>
<li>All lines containing a pattern.</li>
<li>All lines from the beginning of a file to a regular expression</li>
<li>All lines from a regular expression to the end of the file.</li>
<li>All lines between two regular expressions.</li>
<li>Sed can do all that and more. Every command in sed can be proceeded by
an address, range or restriction like the above examples. The
restriction or address immediately precedes the command:</li>
</ul>


<h2 id="Restricting-to-a-line-number">Restricting to a line number</h2>

<p>The simplest restriction is a line number. If you wanted to delete the
first number on line 3, just add a "3" before the command:</p>

<pre><code>sed '3 s/[0-9][0-9]*//' &lt;file >new
</code></pre>

<h2 id="Patterns">Patterns</h2>

<p>Many Unix utilities like vi and more use a slash to search for a regular
expression. Sed uses the same convention, provided you terminate the
expression with a slash. To delete the first number on all lines that
start with a "#," use:</p>

<pre><code>sed '/^#/ s/[0-9][0-9]*//'
</code></pre>

<p>I placed a space after the "/expression/" so it is easier to read. It
isn't necessary, but without it the command is harder to fathom. Sed
does provide a few extra options when specifying regular
expressions. But I'll discuss those later. If the expression starts with
a backslash, the next character is the delimiter. To use a comma instead
of a slash, use:</p>

<pre><code>sed '\,^#, s/[0-9][0-9]*//'
</code></pre>

<p>The main advantage of this feature is searching for slashes. Suppose you
wanted to search for the string "/usr/local/bin" and you wanted to
change it for "/common/all/bin." You could use the backslash to escape
the slash:</p>

<pre><code>sed '/\/usr\/local\/bin/ s/\/usr\/local/\/common\/all/'
</code></pre>

<p>It would be easier to follow if you used an underline instead of a slash
as a search. This example uses the underline in both the search command
and the substitute command:</p>

<pre><code>sed '\_/usr/local/bin_ s_/usr/local_/common/all_'
</code></pre>

<p>This illustrates why sed scripts get the reputation for obscurity. I
could be perverse and show you the example that will search for all
lines that start with a "g," and change each "g" on that line to an "s:"</p>

<pre><code>sed '/^g/s/g/s/g'
</code></pre>

<p>Adding a space and using an underscore after the substitute command
makes this much easier to read:</p>

<pre><code>sed '/^g/ s_g_s_g'
</code></pre>

<p>Er, I take that back. It's hopeless. There is a lesson here: Use
comments liberally in a sed script under SunOS. You may have to remove
the comments to run the script under a different operating system, but
you now know how to write a sed script to do that very easily! Comments
are a Good Thing. You may have understood the script perfectly when you
wrote it. But six months from now it could look like modem noise.</p>

<h2 id="Ranges-by-line-number">Ranges by line number</h2>

<p>You can specify a range on line numbers by inserting a comma between the
numbers. To restrict a substitution to the first 100 lines, you can use:</p>

<pre><code>sed '1,100 s/A/a/'
</code></pre>

<p>If you know exactly how many lines are in a file, you can explicitly
state that number to perform the substitution on the rest of the
file. In this case, assume you used wc to find out there are 532 lines
in the file:</p>

<pre><code>sed '101,532 s/A/a/'
</code></pre>

<p>An easier way is to use the special character "$," which means the last
line in the file.</p>

<pre><code>sed '101,$ s/A/a/'
</code></pre>

<p>The "$" is one of those conventions that mean "last" in utilities like
cat -e, vi, and ed. "cat -e" Line numbers are cumulative if several
files are edited. That is,</p>

<pre><code>sed '200,300 s/A/a/' f1 f2 f3 &gt;new
</code></pre>

<p>is the same as</p>

<pre><code>cat f1 f2 f3 | sed '200,300 s/A/a/' &gt;new
</code></pre>

<h2 id="Ranges-by-patterns">Ranges by patterns</h2>

<p>You can specify two regular expressions as the range. Assuming a "#"
starts a comment, you can search for a keyword, remove all comments
until you see the second keyword. In this case the two keywords are
"start" and "stop:"</p>

<pre><code>sed '/start/,/stop/ s/#.*//'
</code></pre>

<p>The first pattern turns on a flag that tells sed to perform the
substitute command on every line. The second pattern turns off the
flag. If the "start" and "stop" pattern occurs twice, the substitution
is done both times. If the "stop" pattern is missing, the flag is never
turned off, and the substitution will be performed on every line until
the end of the file.</p>

<p>You should know that if the "start" pattern is found, the substitution
occurs on the same line that contains "start." This turns on a switch,
which is line oriented. That is, the next line is read and the
substitute command is checked. If it contains "stop" the switch is
turned off. Switches are line oriented, and not word oriented.</p>

<p>You can combine line numbers and regular expressions. This example will
remove comments from the beginning of the file until it finds the
keyword "start:"</p>

<pre><code>sed -e '1,/start/ s/#.*//'
</code></pre>

<p>This example will remove comments everywhere except the lines between
the two keywords:</p>

<pre><code>sed -e '1,/start/ s/#.*//' -e '/stop/,$ s/#.*//'
</code></pre>

<p>The last example has a range that overlaps the "/start/,/stop/" range,
as both ranges operate on the lines that contain the keywords. I will
show you later how to restrict a command up to, but not including the
line containing the specified pattern.</p>

<p>Before I start discussing the various commands, I should explain that
some commands cannot operate on a range of lines. I will let you know
when I mention the commands. In this next section I will describe three
commands, one of which cannot operate on a range.</p>

<h2 id="Delete-with-d">Delete with d</h2>

<p>Using ranges can be confusing, so you should expect to do some
experimentation when you are trying out a new script. A useful command
deletes every line that matches the restriction: "d." If you want to
look at the first 10 lines of a file, you can use:</p>

<pre><code>sed '11,$ d' &lt;file
</code></pre>

<p>which is similar in function to the head command. If you want to chop
off the header of a mail message, which is everything up to the first
blank line, use:</p>

<pre><code>sed '1,/^$/ d' &lt;file
</code></pre>

<p>You can duplicate the function of the tail command, assuming you know
the length of a file. Wc can count the lines, and expr can subtract 10
from the number of lines. A Bourne shell script to look at the last 10
lines of a file might look like this:</p>

<pre><code>#!/bin/sh
#print last 10 lines of file
# First argument is the filename
lines=`wc -l $1 | awk '{print $1}' `
start=`expr $lines - 10`
sed "1,$start d" $1
</code></pre>

<p>The range for deletions can be regular expressions pairs to mark the
begin and end of the operation. Or it can be a single regular
expression. Deleting all lines that start with a "#" is easy:</p>

<pre><code>sed '/^#/ d'
</code></pre>

<p>Removing comments and blank lines takes two commands. The first removes
every character from the "#" to the end of the line, and the second
deletes all blank lines:</p>

<pre><code>sed -e 's/#.*//' -e '/^$/ d'
</code></pre>

<p>A third one should be added to remove all blanks and tabs immediately
before the end of line:</p>

<pre><code>sed -e 's/#.*//' -e 's/[ ^I]*$//' -e '/^$/ d'
</code></pre>

<p>The character "<sup>I"</sup> is a CTRL-I or tab character. You would have to
explicitly type in the tab. Note the order of operations above, which is
in that order for a very good reason. Comments might start in the middle
of a line, with white space characters before them. Therefore comments
are first removed from a line, potentially leaving white space
characters that were before the comment. The second command removes all
trailing blanks, so that lines that are now blank are converted to empty
lines. The last command deletes empty lines. Together, the three
commands remove all lines containing only comments, tabs or spaces.</p>

<p>This demonstrates the pattern space sed uses to operate on a line. The
actual operation sed uses is:</p>

<ul>
<li>Copy the input line into the pattern space.</li>
<li>Apply the first</li>
<li>sed command on the pattern space, if the address restriction is true.</li>
<li>Repeat with the next sed expression, again</li>
<li>operating on the pattern space.</li>
<li>When the last operation is performed, write out the pattern space</li>
<li>and read in the next line from the input file.</li>
<li>Printing with p</li>
</ul>


<p>Another useful command is the print command: "p." If sed wasn't started
with an "-n" option, the "p" command will duplicate the input. The
command</p>

<pre><code>sed 'p'
</code></pre>

<p>will duplicate every line. If you wanted to double every empty line, use:</p>

<pre><code>sed '/^$/ p'
</code></pre>

<p>Adding the "-n" option turns off printing unless you request it. Another
way of duplicating head's functionality is to print only the lines you
want. This example prints the first 10 lines:</p>

<pre><code>sed -n '1,10 p' &lt;file
</code></pre>

<p>Sed can act like grep by combining the print operator to function on all
lines that match a regular expression:</p>

<pre><code>sed -n '/match/ p'
</code></pre>

<p>which is the same as:</p>

<pre><code>grep match
</code></pre>

<p>Reversing the restriction with !</p>

<p>Sometimes you need to perform an action on every line except those that
match a regular expression, or those outside of a range of
addresses. The "!" character, which often means not in Unix utilities,
inverts the address restriction. You remember that</p>

<pre><code>sed -n '/match/ p'
</code></pre>

<p>acts like the grep command. The "-v" option to grep prints all lines
that don't contain the pattern. Sed can do this with</p>

<pre><code>sed -n '/match/ !p' &lt;/tmp/b
</code></pre>

<h2 id="Relationships-between-d-p-and-">Relationships between d, p, and !</h2>

<p>As you may have noticed, there are often several ways to solve the same
problem with sed. This is because print and delete are opposite
functions, and it appears that "!p" is similar to "d," while "!d" is
similar to "p." I wanted to test this, so I created a 20 line file, and
tried every different combination. The following table, which shows the
results, demonstrates the difference:</p>

<p>Relations between d, p, and !
  Sed      Range   Command   Results</p>

<hr />

<p>  sed -n   1,10    p         Print first 10 lines
  sed -n   11,$    !p        Print first 10 lines
  sed      1,10    !d        Print first 10 lines
  sed      11,$    d         Print first 10 lines</p>

<hr />

<p>  sed -n   1,10    !p        Print last 10 lines
  sed -n   11,$    p         Print last 10 lines
  sed      1,10    d         Print last 10 lines
  sed      11,$    !d        Print last 10 lines</p>

<hr />

<p>  sed -n   1,10    d         Nothing printed
  sed -n   1,10    !d        Nothing printed
  sed -n   11,$    d         Nothing printed
  sed -n   11,$    !d        Nothing printed</p>

<hr />

<p>  sed      1,10    p         Print first 10 lines twice,</p>

<pre><code>             Then next 10 lines once
</code></pre>

<p>  sed      11,$    !p        Print first 10 lines twice,</p>

<pre><code>             Then last 10 lines once
</code></pre>

<hr />

<p>  sed      1,10    !p        Print first 10 lines once,</p>

<pre><code>             Then last 10 lines twice
</code></pre>

<p>  sed      11,$    p         Print first 10 lines once,</p>

<pre><code>             then last 10 lines twice
</code></pre>

<p>This table shows that the following commands are identical:</p>

<pre><code>sed -n '1,10 p'
sed -n '11,$ !p'
sed '1,10 !d'
sed '11,$ d'
</code></pre>

<p>It also shows that the "!" command "inverts" the address range,
operating on the other lines.</p>

<h2 id="The-q-or-quit-command">The q or quit command</h2>

<p>There is one more simple command that can restrict the changes to a set
of lines. It is the "q" command: quit. the third way to duplicate the
head command is:</p>

<pre><code>sed '11 q'
</code></pre>

<p>which quits when the eleventh line is reached. This command is most
useful when you wish to abort the editing after some condition is
reached.</p>

<p>The "q" command is the one command that does not take a range of
addresses. Obviously the command</p>

<pre><code>sed '1,10 q'
</code></pre>

<p>cannot quit 10 times. Instead</p>

<pre><code>sed '1 q'
</code></pre>

<p>or</p>

<pre><code>sed '10 q'
</code></pre>

<p>is correct.</p>

<h2 id="Grouping-with-and-">Grouping with { and }</h2>

<p>The curly braces, "{" and "}," are used to group the commands.</p>

<p>Hardly worth the build up. All that prose and the solution is just
matching squigqles. Well, there is one complication. Since each sed
command must start on its own line, the curly braces and the nested sed
commands must be on separate lines.</p>

<p>Previously, I showed you how to remove comments starting with a "#." If
you wanted to restrict the removal to lines between special "begin" and
"end" key words, you could use:</p>

<pre><code>#!/bin/sh
# This is a Bourne shell script that removes #-type comments
# between 'begin' and 'end' words.
sed -n '
  /begin/,/end/ {
       s/#.*//
       s/[ ^I]*$//
       /^$/ d
       p
  }
'
</code></pre>

<p>These braces can be nested, which allow you to combine address ranges. You could perform the same action as before, but limit the change to the first 100 lines:</p>

<pre><code>#!/bin/sh
# This is a Bourne shell script that removes #-type comments
# between 'begin' and 'end' words.
sed -n '
  1,100 {
    /begin/,/end/ {
         s/#.*//
         s/[ ^I]*$//
         /^$/ d
         p
    }
  }
'
</code></pre>

<p>You can place a "!" before a set of curly braces. This inverts the address, which removes comments from all lines except those between the two reserved words:</p>

<pre><code>#!/bin/sh
sed '
  /begin/,/end/ !{
       s/#.*//
       s/[ ^I]*$//
       /^$/ d
       p
  }
'
</code></pre>

<h2 id="Writing-a-file-with-the-w-command">Writing a file with the 'w' command</h2>

<p>You may remember that the substitute command can write to a file. Here
again is the example that will only write lines that start with an even
number (and followed by a space):</p>

<pre><code>sed -n 's/^[0-9]*[02468] /&amp;/w even'&lt;file I used the "&amp;" in the
replacement part of the substitution command so that the line would not
be changed. A simpler example is to use the "w" command, which has the
same syntax as the "w" flag in the substitute command: sed -n
'/^[0-9]*[02468]/ w even' &lt;file
</code></pre>

<p>Remember - only one space must follow the command. Anything else will be
considered part of the file name. The "w" command also has the same
limitation as the "w" flag: only 10 files can be opened in sed.</p>

<h2 id="Reading-in-a-file-with-the-r-command">Reading in a file with the 'r' command</h2>

<p>There is also a command for reading files. The command</p>

<pre><code>sed '$r end' &lt;in>out
</code></pre>

<p>will append the file "end" at the end of the file (address "$)." The following will insert a file after the line with the word "INCLUDE:"</p>

<pre><code>sed '/INCLUDE/ r file' &lt;in >out
</code></pre>

<p>You can use the curly braces to delete the line having the "INCLUDE" command on it:</p>

<pre><code>#!/bin/sh
sed '/INCLUDE/ {
  r file
  d
}'
</code></pre>

<p>The order of the delete command "d" and the read file command "r" is
important. Change the order and it will not work. There are two subtle
actions that prevent this from working. The first is the "r" command
writes the file to the output stream. The file is not inserted into the
pattern space, and therefore cannot be modified by any
command. Therefore the delete command does not affect the data read from
the file.</p>

<p>The other subtlety is the "d" command deletes the current data in the
pattern space. Once all of the data is deleted, it does make sense that
no other action will be attempted. Therefore a "d" command executed in a
curly brace also aborts all further actions. As an example, the
substitute command below is never executed:</p>

<pre><code>#!/bin/sh
# this example is WRONG
sed -e '1 {
  d
  s/.*//
}'
</code></pre>

<p>The earlier example is a crude version of the C preprocessor
program. The file that is included has a predetermined name. It would be
nice if sed allowed a variable (e.g "\1)" instead of a fixed file
name. Alas, sed doesn't have this ability. You could work around this
limitation by creating sed commands on the fly, or by using shell quotes
to pass variables into the sed script. Suppose you wanted to create a
command that would include a file like cpp, but the filename is an
argument to the script. An example of this script is:</p>

<pre><code>% include 'sys/param.h' &lt;file.c &gt;file.c.new
</code></pre>

<p>A shell script to do this would be:</p>

<pre><code>#!/bin/sh
# watch out for a '/' in the parameter
# use alternate search delimiter
sed -e '\_#INCLUDE &lt;'"$1"'>_{
  r '"$1"'
  d
}'
Let me elaborate. If you had a file that contains
</code></pre>

<ul>
<li>Test first file</li>
<li><h1>INCLUDE <var>file1</var></h1></li>
<li>Test second file</li>
<li><h1>INCLUDE <var>file2</var></h1></li>
<li>you could use the command</li>
</ul>


<h2 id="SunOS-and-the-Comment-Command">SunOS and the # Comment Command</h2>

<p>As we dig deeper into sed, comments will make the commands easier to
follow. Most versions of sed only allow one line as a comment, and it
must be the first line. SunOS allows more than one comment, and these
comments don't have to be first. The last example could be:</p>

<pre><code>#!/bin/sh
# watch out for a '/' in the parameter
# use alternate search delimiter
sed -e '\_#INCLUDE &lt;'"$1"'>_{

  # read the file
  r '"$1"'

  # delete any characters in the pattern space
  # and read the next line in
  d
}'
</code></pre>

<h2 id="Adding-Changing-Inserting-new-lines">Adding, Changing, Inserting new lines</h2>

<p>Sed has three commands used to add new lines to the output
stream. Because an entire line is added, the new line is on a line by
itself to emphasize this. There is no option, an entire line is used,
and it must be on its own line. If you are familiar with many unix
utilities, you would expect sed to use a similar convention: lines are
continued by ending the previous line with a "\". The syntax to these
commands is finicky, like the "r" and "w" commands.</p>

<p>Append a line with 'a'</p>

<p>The "a" command appends a line after the range or pattern. This example
will add a line after every line with "WORD:"</p>

<pre><code>#!/bin/sh
sed '
/WORD/ a\
Add this line after every line with WORD
'
</code></pre>

<p>You could eliminate two lines in the shell script if you wish:</p>

<pre><code>#!/bin/sh
sed '/WORD/ a\
</code></pre>

<p>Add this line after every line with WORD'</p>

<p>I prefer the first form because it's easier to add a new command by
adding a new line and because the intent is clearer. There must not be a
space after the "\".</p>

<h2 id="Insert-a-line-with-i-">Insert a line with 'i'</h2>

<p>You can insert a new line before the pattern with the "i" command:</p>

<pre><code>#!/bin/sh
sed '
/WORD/ i\
Add this line before every line with WORD
'
</code></pre>

<h2 id="Change-a-line-with-c-">Change a line with 'c'</h2>

<p>You can change the current line with a new line.</p>

<pre><code>#!/bin/sh
sed '
/WORD/ c\
Replace the current line with the line
'
</code></pre>

<p>A "d" command followed by a "a" command won't work, as I discussed
earlier. The "d" command would terminate the current actions. You can
combine all three actions using curly braces:</p>

<pre><code>#!/bin/sh
sed '
/WORD/ {
i\
Add this line before
a\
Add this line after
c\
Change the line to this one
}'
</code></pre>

<h2 id="Leading-tabs-and-spaces-in-a-sed-script">Leading tabs and spaces in a sed script</h2>

<p>Sed ignores leading tabs and spaces in all commands. However these white
space characters may or may not be ignored if they start the text
following a "a," "c" or "i" command. In SunOS, both "features" are
available. The Berkeley (and Linux) style sed is in /usr/bin, and the
AT&amp;T version (System V) is in /usr/5bin/.</p>

<p>To elaborate, the /usr/bin/sed command retains white space, while the
/usr/5bin/sed strips off leading spaces. If you want to keep leading
spaces, and not care about which version of sed you are using, put a "\"
as the first character of the line:</p>

<pre><code>#!/bin/sh
sed '
  a\
\   This line starts with a tab
'
</code></pre>

<h2 id="Adding-more-than-one-line">Adding more than one line</h2>

<p>All three commands will allow you to add more than one line. Just end
each line with a "\:"</p>

<pre><code>#!/bin/sh
sed '
/WORD/ a\
Add this line\
This line\
And this line
'
</code></pre>

<h2 id="Adding-lines-and-the-pattern-space">Adding lines and the pattern space</h2>

<p>I have mentioned the pattern space before. Most commands operate on the
pattern space, and subsequent commands may act on the results of the
last modification. The three previous commands, like the read file
command, add the new lines to the output stream, bypassing the pattern
space.</p>

<h2 id="Address-ranges-and-the-above-commands">Address ranges and the above commands</h2>

<p>You may remember in my last tutorial I warned you that some commands can
take a range of lines, and others cannot. To be precise, the commands
"a," "i," "r," and "q" will not take a range like "1,100" or
"/begin/,/end/." The documentation states that the read command can take
a range, but I get an error when I try this. The "c" or change command
allows this, and it will let you change several lines into one:</p>

<pre><code>#!/bin/sh
sed '
/begin/,/end/ c\
***DELETED***
'
</code></pre>

<p>If you need to do this, you can use the curly braces, as that will let
you perform the operation on every line:</p>

<pre><code>#!/bin/sh
# add a blank line after every line
sed '1,$ {
  a\

}'
</code></pre>

<h2 id="Multi-Line-Patterns">Multi-Line Patterns</h2>

<p>Most UNIX utilities are line oriented. Regular expressions are line
oriented. Searching for patterns that covers more than one line is not
an easy task. (Hint: It will be very shortly.)</p>

<p>Sed reads in a line of text, performs commands which may modify the
line, and outputs modification if desired. The main loop of a sed script
looks like this:</p>

<p>The next line is read from the input file and places in the pattern
space. If the end of file is found, and if there are additional files to
read, the current file is closed, the next file is opened, and the first
line of the new file is placed into the pattern space.  The line count
is incremented by one. Opening a new file does not reset this number.
Each sed command is examined. If there is a restriction placed on the
command, and the current line in the pattern space meets that
restriction, the command is executed. Some commands, like "n" or "d"
cause sed to go to the top of the loop. The "q" command causes sed to
stop. Otherwise the next command is examined.  After all of the commands
are examined, the pattern space is output unless sed has the optional
"-n" argument.  The restriction before the command determines if the
command is executed. If the restriction is a pattern, and the operation
is the delete command, then the following will delete all lines that
have the pattern:</p>

<pre><code>/PATTERN/ d
</code></pre>

<p>If the restriction is a pair of numbers, then the deletion will happen
if the line number is equal to the first number or greater than the
first number and less than or equal to the last number:</p>

<pre><code>10,20 d
</code></pre>

<p>If the restriction is a pair of patterns, there is a variable that is
kept for each of these pairs. If the variable is false and the first
pattern is found, the variable is made true. If the variable is true,
the command is executed. If the variable is true, and the last pattern
is on the line, after the command is executed the variable is turned
off:</p>

<pre><code>/begin/,/end/ d
</code></pre>

<p>Whew! That was a mouthful. If you have read carefully up to here, you
should have breezed through this. You may want to refer back, because I
covered several subtle points. My choice of words was deliberate. It
covers some unusual cases, like:</p>

<pre><code># what happens if the second number
# is less than the first number?
sed -n '20,1 p' file
and

# generate a 10 line file with line numbers
# and see what happens when two patterns overlap
yes | head -10 | cat -n | \
sed -n -e '/1/,/7/ p' -e '/5/,/9/ p'
</code></pre>

<p>Enough mental punishment. Here is another review, this time in a table
format. Assume the input file contains the following lines:</p>

<pre><code>AB
CD
EF
GH
IJ
</code></pre>

<p>When sed starts up, the first line is placed in the pattern space. The
next line is "CD." The operations of the "n," "d," and "p" commands can
be summarized as:</p>

<p>+----------------+---------+------------------------------------------+
|Pattern   Next  | Command | Output        New Pattern   New Next |
|Space     Input |     |               Space         Input    |
+----------------+---------+------------------------------------------+
|AB    CD    | n       | <var>default</var>     CD       EF       |
|AB    CD    | d       | -             CD        EF       |
|AB    CD    | p       | AB            CD        EF       |
+----------------+---------+------------------------------------------+</p>

<p>The "n" command may or may not generate output depending upon the
existence of the "-n" flag.</p>

<p>That review is a little easier to follow, isn't it? Before I jump into
multi-line patterns, I wanted to cover three more commands:</p>

<p>Print line number with =</p>

<p>The "=" command prints the current line number to standard output. One
way to find out the line numbers that contain a pattern is to use:</p>

<pre><code># add line numbers first,
# then use grep,
# then just print the number
cat -n file | grep 'PATTERN' | awk '{print $1}'
</code></pre>

<p>The sed solution is:</p>

<pre><code>sed -n '/PATTERN/ =' file
</code></pre>

<p>Earlier I used the following to find the number of lines in a file</p>

<pre><code>#!/bin/sh
lines=`wc -l file | awk '{print $1}' `
</code></pre>

<p>Using the "=" command can simplify this:</p>

<pre><code>#!/bin/sh
lines=`sed -n '$=' file `
</code></pre>

<p>The "=" command only accepts one address, so if you want to print the
number for a range of lines, you must use the curly braces:</p>

<pre><code>#!/bin/sh
# Just print the line numbers
sed -n '/begin/,/end/ {
=
d
}' file
</code></pre>

<p>Since the "=" command only prints to standard output, you cannot print
the line number on the same line as the pattern. You need to edit
multi-line patterns to do this.</p>

<p>Transform with y</p>

<p>If you wanted to change a word from lower case to upper case, you could
write 26 character substitutions, converting "a" to "A," etc. Sed has a
command that operates like the tr program. It is called the "y"
command. For instance, to change the letters "a" through "f" into their
upper case form, use:</p>

<pre><code>sed 'y/abcdef/ABCDEF/' file
</code></pre>

<p>I could have used an example that converted all 26 letters into upper
case, and while this column covers a broad range of topics, the "column"
prefers a narrower format.</p>

<p>If you wanted to convert a line that contained a hexadecimal number
(e.g. 0x1aff) to upper case (0x1AFF), you could use:</p>

<pre><code>sed '/0x[0-9a-zA-Z]*/ y/abcdef/ABCDEF' file
</code></pre>

<p>This works fine if there are only numbers in the file. If you wanted to
change the second word in a line to upper case, you are out of luck -
unless you use multi-line editing. (Hey - I think there is some sort of
theme here!)</p>

<h2 id="Displaying-control-characters-with-a-l">Displaying control characters with a l</h2>

<p>The "l" command prints the current pattern space. It is therefore useful
in debugging sed scripts. It also converts unprintable characters into
printing characters by outputting the value in octal preceded by a "\"
character. I found it useful to print out the current pattern space,
while probing the subtleties of sed.</p>

<h2 id="Working-with-Multiple-Lines">Working with Multiple Lines</h2>

<p>There are three new commands used in multiple-line patterns: "N," "D,"
and "P." I will explain their relation to the matching "n," "d," and "p"
single-line commands.</p>

<p>The "n" command will print out the current pattern space (unless the
"-n" flag is used), empty the current pattern space, and read in the
next line of input. The "N" command does not print out the current
pattern space and does not empty the pattern space. It reads in the next
line, but appends a new line character along with the input line itself
to the pattern space.</p>

<p>The "d" command deleted the current pattern space, reads in the next
line, puts the new line into the pattern space, and aborts the current
command, and starts execution at the first sed command. This is called
starting a new "cycle." The "D" command deletes the first portion of the
pattern space, up to the new line character, leaving the rest of the
pattern alone. Like "d," it stops the current command and starts the
command cycle over again. However, it will not print the current pattern
space. You must print it yourself, a step earlier. If the "D" command is
executed with a group of other commands in a curly brace, commands after
the "D" command are ignored. The next group of sed commands is executed,
unless the pattern space is emptied. If this happens, the cycle is
started from the top and a new line is read.</p>

<p>The "p" command prints the entire pattern space. The "P" command only
prints the first part of the pattern space, up to the NEWLINE character.</p>

<p>Some examples might demonstrate "N" by itself isn't very useful. the
filter</p>

<pre><code>sed -e 'N'
</code></pre>

<p>doesn't modify the input stream. Instead, it combines the first and
second line, then prints them, combines the third and fourth line, and
prints them, etc. It does allow you to use a new "anchor" character:
"\n." This matches the new line character that separates multiple lines
in the pattern space. If you wanted to search for a line that ended with
the character "#," and append the next line to it, you could use</p>

<pre><code>#!/bin/sh
sed '
# look for a "#" at the end of the line
/#$/ {
# Found one - now read in the next line
  N
# delete the "#" and the new line character,
  s/#\n//
}' file
</code></pre>

<p>You could search for two lines containing "ONE" and "TWO" and only print
out the two consecutive lines:</p>

<pre><code>#!/bin/sh
sed -n '
/ONE/ {
# found "ONE" - read in next line
  N
# look for "TWO" on the second line
# and print if there.
  /\n.*TWO/ p
}' file
</code></pre>

<p>The next example would delete everything between "ONE" and "TWO:"</p>

<pre><code>#!/bin/sh
sed '
/ONE/ {
# append a line
  N
# search for TWO on the second line
  /\n.*TWO/ {
# found it - now edit making one line
    s/ONE.*\n.*TWO/ONE TWO/
  }
}' file
</code></pre>

<p>You can either search for a particular pattern on two consecutive lines,
or you can search for two consecutive words that may be split on a line
boundary. The next example will look for two words which are either on
the same line or one is on the end of a line and the second is on the
beginning of the next line. If found, the first word is deleted:</p>

<pre><code>#!/bin/sh
sed '
/ONE/ {
# append a line
  N
# "ONE TWO" on same line
  s/ONE TWO/TWO/
# "ONE
# TWO" on two consecutive lines
  s/ONE\nTWO/TWO/
}' file
</code></pre>

<p>Let's use the
"D" command, and if we find a line containing
"TWO" immediately after a line containing
"ONE," then delete the first line:</p>

<pre><code>#!/bin/sh
sed '
/ONE/ {
# append a line
  N
# if TWO found, delete the first line
  /\n.*TWO/ D
}' file
</code></pre>

<p>If we wanted to print the first line instead of deleting it, and not
print every other line, change the "D" to a "P" and add a "-n" as an
argument to sed:</p>

<pre><code>#!/bin/sh
sed -n '
# by default - do not print anything
/ONE/ {
# append a line
  N
# if TWO found, print the first line
  /\n.*TWO/ P
}' file
</code></pre>

<p>It is very common to combine all three multi-line commands. The typical
order is "N," "P" and lastly "D." This one will delete everything
between "ONE" and "TWO" if they are on one or two consecutive lines:</p>

<pre><code>#!/bin/sh
sed '
/ONE/ {
# append the next line
  N
# look for "ONE" followed by "TWO"
  /ONE.*TWO/ {
#   delete everything between
    s/ONE.*TWO/ONE TWO/
#   print
    P
#   then delete the first line
    D
  }
}' file
</code></pre>

<p>Earlier I talked about the "=" command, and using it to add line numbers
to a file. You can use two invocations of sed to do this (although it is
possible to do it with one, but that must wait until next section). The
first sed command will output a line number on one line, and then print
the line on the next line. The second invocation of sed will merge the
two lines together:</p>

<pre><code>#!/bin/sh
sed '=' file | \
sed '{
  N
  s/\n/ /
}'
</code></pre>

<p>If you find it necessary, you can break one line into two lines, edit
them, and merge them together again. As an example, if you had a file
that had a hexadecimal number followed by a word, and you wanted to
convert the first word to all upper case, you can use the "y" command,
but you must first split the line into two lines, change one of the two,
and merge them together. That is, a line containing</p>

<pre><code>0x1fff table2
</code></pre>

<p>will be changed into two lines:</p>

<pre><code>0x1fff
table2
</code></pre>

<p>and the first line will be converted into upper case. I will use tr to
convert the space into a new line:</p>

<pre><code>#!/bin/sh
tr ' ' '\012' file|
sed ' {
  y/abcdef/ABCDEF/
  N
  s/\n/ /
}'
</code></pre>

<p>It isn't obvious, but sed could be used instead of tr. You can embed a
new line in a substitute command, but you must escape it with a
backslash. It is unfortunate that you must use "\n" in the left side of
a substitute command, and an embedded new line in the right hand
side. Heavy sigh. Here is the example:</p>

<pre><code>#!/bin/sh
sed '
s/ /\
/' | \
sed ' {
  y/abcdef/ABCDEF/
  N
  s/\n/ /
}'
</code></pre>

<p>Sometimes I add a special character as a marker, and look for that
character in the input stream. When found, it indicates the place a
blank used to be. A backslash is a good character, except it must be
escaped with a backslash, and makes the sed script obscure. Save it for
that guy who keeps asking dumb questions. The sed script to change a
blank into a "\" following by a new line would be:</p>

<pre><code>#!/bin/sh
sed 's/ /\\\
/' file
</code></pre>

<h2 id="Yeah-That-s-the-ticket-Or-use-the-C-shell-and-really-confuse-him-">Yeah. That's the ticket. Or use the C shell and really confuse him!</h2>

<pre><code>#!/bin/csh -f
sed '\
s/ /\\\\
/' file
</code></pre>

<p>A few more examples of that, and he'll never ask you a question again! I
think I'm getting carried away. I'll summarize with a chart that covers
the features we've talked about:</p>

<p>+----------------+---------+------------------------------------------+
|Pattern   Next  | Command | Output        New Pattern   New Next |
|Space     Input |     |               Space         Input    |
+----------------+---------+------------------------------------------+
|AB    CD    | n       | <var>default</var>      CD      EF       |
|AB    CD    | N       | -             AB\nCD        EF       |
|AB    CD    | d       | -             CD        EF       |
|AB    CD    | D       | -             CD        EF       |
|AB    CD    | p       | AB            CD        EF       |
|AB    CD    | P       | AB            CD        EF       |
+----------------+---------+------------------------------------------+
|AB\nCD    EF    | n       | <var>default</var>           EF         GH       |
|AB\nCD    EF    | N       | -             AB\nCD\nEF    GH       |
|AB\nCD    EF    | d       | -             EF        GH       |
|AB\nCD    EF    | D       | -             CD        EF       |
|AB\nCD    EF    | p       | AB\nCD        AB\nCD        EF       |
|AB\nCD    EF    | P       | AB            AB\nCD        EF       |
+----------------+---------+------------------------------------------+</p>

<p>Using newlines in sed scripts</p>

<p>Occasionally one wishes to use a new line character in a sed
script. Well, this has some subtle issues here. If one wants to search
for a new line, one has to use "\n." Here is an example where you search
for a phrase, and delete the new line character after that phrase -
joining two lines together.</p>

<pre><code>(echo a;echo x;echo y) | sed '/x$/ {
N
s:x\n:x:
}'
</code></pre>

<p>which generates</p>

<pre><code>a
xy
</code></pre>

<p>However, if you are inserting a new line, don't use "\n" - instead insert a literal new line character:</p>

<pre><code>(echo a;echo x;echo y) | sed 's:x:X\
:'
</code></pre>

<p>generates</p>

<pre><code>a
X

y
</code></pre>

<h2 id="The-Hold-Buffer">The Hold Buffer</h2>

<p>So far we have talked about three concepts of sed: (1) The input stream
or data before it is modified, (2) the output stream or data after it
has been modified, and (3) the pattern space, or buffer containing
characters that can be modified and send to the output stream.</p>

<p>There is one more "location" to be covered: the hold buffer or hold
space. Think of it as a spare pattern buffer. It can be used to "copy"
or "remember" the data in the pattern space for later. There are five
commands that use the hold buffer.</p>

<h2 id="Exchange-with-x">Exchange with x</h2>

<p>The "x" command eXchanges the pattern space with the hold buffer. By
itself, the command isn't useful. Executing the sed command</p>

<p>sed 'x' as a filter adds a blank line in the front, and deletes the last
line. It looks like it didn't change the input stream significantly, but
the sed command is modifying every line.</p>

<p>The hold buffer starts out containing a blank line. When the "x" command
modifies the first line, line 1 is saved in the hold buffer, and the
blank line takes the place of the first line. The second "x" command
exchanges the second line with the hold buffer, which contains the first
line. Each subsequent line is exchanged with the preceding line. The
last line is placed in the hold buffer, and is not exchanged a second
time, so it remains in the hold buffer when the program terminates, and
never gets printed. This illustrates that care must be taken when
storing data in the hold buffer, because it won't be output unless you
explicitly request it.</p>

<p>Example of Context Grep</p>

<p>One use of the hold buffer is to remember previous lines. An example of
this is a utility that acts like grep as it shows you the lines that
match a pattern. In addition, it shows you the line before and after the
pattern. That is, if line 8 contains the pattern, this utility would
print lines 7, 8 and 9.</p>

<p>One way to do this is to see if the line has the pattern. If it does not
have the pattern, put the current line in the hold buffer. If it does,
print the line in the hold buffer, then the current line, and then the
next line. After each set, three dashes are printed. The script checks
for the existence of an argument, and if missing, prints an
error. Passing the argument into the sed script is done by turning off
the single quote mechanism, inserting the "$1" into the script, and
starting up the single quote again:</p>

<pre><code>#!/bin/sh
# grep3 - prints out three lines around pattern
# if there is only one argument, exit

case $# in
  1);;
  *) echo "Usage: $0 pattern";exit;;
esac;
# I hope the argument doesn't contain a /
# if it does, sed will complain

# use sed -n to disable printing
# unless we ask for it
sed -n '
'/$1/' !{
  #no match - put the current line in the hold buffer
  x
  # delete the old one, which is
  # now in the pattern buffer
  d
}
'/$1/' {
  # a match - get last line
  x
  # print it
  p
  # get the original line back
  x
  # print it
  p
  # get the next line
  n
  # print it
  p
  # now add three dashes as a marker
  a\
---
  # now put this line into the hold buffer
  x
}'
</code></pre>

<p>You could use this to show the three lines around a keyword, i.e.:</p>

<pre><code>grep3 vt100 &lt;/etc/termcap
</code></pre>

<p>Hold with h or H</p>

<p>The "x" command exchanges the hold buffer and the pattern buffer. Both
are changed. The "h" command copies the pattern buffer into the hold
buffer. The pattern buffer is unchanged. An identical script to the
above uses the hold commands:</p>

<pre><code>#!/bin/sh
# grep3 version b - another version using the hold commands
# if there is only one argument, exit

case $# in
  1);;
  *) echo "Usage: $0 pattern";exit;;
esac;

# again - I hope the argument doesn't contain a /

# use sed -n to disable printing

sed -n '
'/$1/' !{
  # put the non-matching line in the hold buffer
  h
}
'/$1/' {
  # found a line that matches
  # append it to the hold buffer
  H
  # the hold buffer contains 2 lines
  # get the next line
  n
  # and add it to the hold buffer
  H
  # now print it back to the pattern space
  x
  # and print it.
  p
  # add the three hyphens as a marker
  a\
---
}'
</code></pre>

<p>Keeping more than one line in the hold buffer</p>

<p>The "H" command allows you to combine several lines in the hold
buffer. It acts like the "N" command as lines are appended to the
buffer, with a "\n" between the lines. You can save several lines in the
hold buffer, and print them only if a particular pattern is found later.</p>

<p>As an example, take a file that uses spaces as the first character of a
line as a continuation character. The files /etc/termcap, /etc/printcap,
makefile and mail messages use spaces or tabs to indicate a continuing
of an entry. If you wanted to print the entry before a word, you could
use this script. I use a "<sup>I"</sup> to indicate an actual tab character:</p>

<pre><code>#!/bin/sh
# print previous entry
sed -n '
/^[ ^I]/!{
  # line does not start with a space or tab,
  # does it have the pattern we are interested in?
  '/$1/' {
    # yes it does. print three dashes
    i\
---
    # get hold buffer, save current line
    x
    # now print what was in the hold buffer
    p
    # get the original line back
    x
  }
  # store it in the hold buffer
  h
}
# what about lines that start
# with a space or tab?
/^[ ^I]/ {
  # append it to the hold buffer
  H
}'
</code></pre>

<p>You can also use the "H" to extend the context grep. In this example,
the program prints out the two lines before the pattern, instead of a
single line. The method to limit this to two lines is to use the "s"
command to keep one new line, and deleting extra lines. I call it
grep4:</p>

<pre><code>#!/bin/sh

# grep4: prints out 4 lines around pattern
# if there is only one argument, exit

case $# in
  1);;
  *) echo "Usage: $0 pattern";exit;;
esac;

sed -n '
'/$1/' !{
  # does not match - add this line to the hold space
  H
  # bring it back into the pattern space
  x
  # Two lines would look like .*\n.*
  # Three lines look like .*\n.*\n.*
  # Delete extra lines - keep two
  s/^.*\n\(.*\n.*\)$/\1/
  # now put the two lines (at most) into
  # the hold buffer again
  x
}
'/$1/' {
  # matches - append the current line
  H
  # get the next line
  n
  # append that one also
  H
  # bring it back, but keep the current line in
  # the hold buffer. This is the line after the pattern,
  # and we want to place it in hold in case the next line
  # has the desired pattern
  x
  # print the 4 lines
  p
  # add the mark
  a\
---
}'
</code></pre>

<p>You can modify this to print any number of lines around a pattern. As
you can see, you must remember what is in the hold space, and what is in
the pattern space. There are other ways to write the same routine.</p>

<h2 id="Get-with-g-or-G">Get with g or G</h2>

<p>Instead of exchanging the hold space with the pattern space, you can
copy the hold space to the pattern space with the "g" command. This
deletes the pattern space. If you want to append to the pattern space,
use the "G" command. This adds a new line to the pattern space, and
copies the hold space after the new line.</p>

<p>Here is another version of the "grep3" command. It works just like the
previous one, but is implemented differently. This illustrates that sed
has more than one way to solve many problems. What is important is you
understand your problem, and document your solution:</p>

<pre><code>#!/bin/sh
# grep3 version c: use 'G'  instead of H

# if there is only one argument, exit

case $# in
  1);;
  *) echo "Usage: $0 pattern";exit;;
esac;

# again - I hope the argument doesn't contain a /

sed -n '
'/$1/' !{
  # put the non-matching line in the hold buffer
  h
}
'/$1/' {
  # found a line that matches
  # add the next line to the pattern space
  N
  # exchange the previous line with the
  # 2 in pattern space
  x
  # now add the two lines back
  G
  # and print it.
  p
  # add the three hyphens as a marker
  a\
---
  # remove first 2 lines
  s/.*\n.*\n\(.*\)$/\1/
  # and place in the hold buffer for next time
  h
}'
</code></pre>

<p>The "G" command makes it easy to have two copies of a line. Suppose you
wanted to the convert the first hexadecimal number to uppercase, and
don't want to use the script I described in an earlier column</p>

<pre><code>#!/bin/sh
# change the first hex number to upper case format
# uses sed twice
# used as a filter
# convert2uc &lt;in >out
sed '
s/ /\
/' | \
sed ' {
  y/abcdef/ABCDEF/
  N
  s/\n/ /
}'
</code></pre>

<p>Here is a solution that does not require two invocations of sed:</p>

<pre><code>#!/bin/sh
# convert2uc version b
# change the first hex number to upper case format
# uses sed once
# used as a filter
# convert2uc &lt;in >out
sed '
{
  # remember the line
  h
  #change the current line to upper case
  y/abcdef/ABCDEF/
  # add the old line back
  G
  # Keep the first word of the first line,
  # and second word of the second line
  # with one humongeous regular expression
  s/^\([^ ]*\) .*\n[^ ]* \(.*\)/\1 \2/
}'
</code></pre>

<p>Carl Henrik Lunde suggested a way to make this simpler. I was working too hard.</p>

<pre><code>#!/bin/sh
# convert2uc version b
# change the first hex number to upper case format
# uses sed once
# used as a filter
# convert2uc &lt;in >out
sed '
{
  # remember the line
  h
  #change the current line to upper case
  y/abcdef/ABCDEF/
  # add the old line back
  G
  # Keep the first word of the first line,
  # and second word of the second line
  # with one humongeous regular expression
  s/ .* / / # delete all but the first and last word
}'
</code></pre>

<p>This example only converts the letters "a" through "f" to upper
case. This was chosen to make the script easier to print in these narrow
columns. You can easily modify the script to convert all letters to
uppercase, or to change the first letter, second word, etc.</p>

<h2 id="Flow-Control">Flow Control</h2>

<p>As you learn about sed you realize that it has its own programming
language. It is true that it's a very specialized and simple
language. What language would be complete without a method of changing
the flow control? There are three commands sed uses for this. You can
specify a label with an text string preceded by a colon. The "b" command
branches to the label. The label follows the command. If no label is
there, branch to the end of the script. The "t" command is used to test
conditions. Before I discuss the "t" command, I will show you an example
using the "b" command.</p>

<p>This example remembers paragraphs, and if it contains the pattern
(specified by an argument), the script prints out the entire paragraph.</p>

<pre><code>#!/bin/sh
sed -n '
# if an empty line, check the paragraph
/^$/ b para
# else add it to the hold buffer
H
# at end of file, check paragraph
$ b para
# now branch to end of script
b
# this is where a paragraph is checked for the pattern
:para
# return the entire paragraph
# into the pattern space
x
# look for the pattern, if there - print
/'$1'/ p
'
</code></pre>

<h2 id="Testing-with-t">Testing with t</h2>

<p>You can execute a branch if a pattern is found. You may want to execute
a branch only if a substitution is made. The command "t label" will
branch to the label if the last substitute command modified the pattern
space.</p>

<p>One use for this is recursive patterns. Suppose you wanted to remove
white space inside parenthesis. These parentheses might be nested. That
is, you would want to delete a string that looked like "( ( ( ())) )."
The sed expressions</p>

<pre><code>sed 's/([ ^I]*)/g'
</code></pre>

<p>would only remove the innermost set. You would have to pipe the data
through the script four times to remove each set or parenthesis. You
could use the regular expression</p>

<pre><code>sed 's/([ ^I()]*)/g'
</code></pre>

<p>but that would delete non-matching sets of parenthesis. The "t" command
would solve this:</p>

<pre><code>#!/bin/sh
sed '
:again
  s/([ ^I]*)//g
  t again
'
</code></pre>

<h2 id="An-alternate-way-of-adding-comments">An alternate way of adding comments</h2>

<p>There is one way to add comments in a sed script if you don't have a
version that supports it. Use the "a" command with the line number of
zero:</p>

<pre><code>#!/bin/sh
sed '
/begin/ {
0i\
  This is a comment\
  It can cover several lines\
  It will work with any version of sed
}'
</code></pre>

<h2 id="The-poorly-documented-">The poorly documented ;</h2>

<p>There is one more sed command that isn't well documented. It is the ";"
command. This can be used to combined several sed commands on one
line. Here is the grep4 script I described earlier, but without the
comments or error checking and with semicolons between commands:</p>

<pre><code>#!/bin/sh
sed -n '
'/$1/' !{;H;x;s/^.*\n\(.*\n.*\)$/\1/;x;}
'/$1/' {;H;n;H;x;p;a\
---
}'
</code></pre>

<p>Yessireebob! Definitely character building. I think I have made my
point. As far as I am concerned, the only time the semicolon is useful
is when you want to type the sed script on the command line. If you are
going to place it in a script, format it so it is readable. I have
mentioned earlier that many versions of sed do not support comments
except on the first line. You may want to write your scripts with
comments in them, and install them in "binary" form without
comments. This should not be difficult. After all, you have become a sed
guru by now. I won't even tell you how to write a script to strip out
comments. That would be insulting your intelligence. Also - some
operating systems do NOT let you use semicolons. So if you see a script
with semicolons, and it does not work on a non-Linux system, replace the
semicolon with a new line character. (As long as you are not using
csh/tcsh, but that's another topic.</p>

<h2 id="Passing-regular-expressions-as-arguments">Passing regular expressions as arguments</h2>

<p>In the earlier scripts, I mentioned that you would have problems if you
passed an argument to the script that had a slash in it. In fact,
regular expression might cause you problems. A script like the following
is asking to be broken some day:</p>

<pre><code>#!/bin/sh
sed 's/'"$1"'//g'
</code></pre>

<p>If the argument contains any of these characters in it, you may get a
broken script: "/.*[]<sup>$"</sup> For instance, if someone types a "/" then the
substiture command will see four delimiters instead of three. You will
also get syntax errors if you provide a "]" without a "]". One solution
is to have the user put a backslash before any of these characters when
they pass it as an argument. However, the user has to know which
characters are special.</p>

<p>Another solution is to add a backslash before each of those characters
in the script</p>

<pre><code>#!/bin/sh
arg=`echo "$1" | sed 's:[]\[\^\$\.\*\/]:\\\\&amp;:g'`
sed 's/'"$arg"'//g'
</code></pre>

<h2 id="Command-Summary">Command Summary</h2>

<pre><code>+----------------------------------------------------------+
 |Command   Address            Modifications to             |
 |         or Range   Input  Output   Pattern   Hold        |
 |                     Stream    Stream   Space     Buffer    |
 +--------------------------------------------------------+
 |=        -           -       Y        -           -           |
 |a        1           -       Y        -           -           |
 |b        2           -       -        -           -           |
 |c        2           -       Y        -           -           |
 |d        2           Y       -        Y           -           |
 |D        2           Y       -        Y           -           |
 |g        2           -       -        Y           -           |
 |G        2           -       -        Y           -           |
 |h        2           -       -        -           Y           |
 |H        2           -       -        -           Y           |
 |i        1           -       Y        -           -           |
 |l        1           -       Y        -           -           |
 |n        2           Y       *        -           -           |
 |N        2           Y       -        Y           -           |
 |p        2           -       Y        -           -           |
 |P        2           -       Y        -           -           |
 |q        1           -       -        -           -           |
 |r        1           -       Y        -           -           |
 |s        2           -       -        Y           -           |
 |t        2           -       -        -           -           |
 |w        2           -       Y        -           -           |
 |x        2           -       -        Y           Y           |
 |y        2           -       -        Y           -           |
 +--------------------------------------------------------+
</code></pre>

<p>The "n" command may or may not generate output, depending on the "-n" option. The "r" command can only have one address, despite the documentation.</p>

<h2 id="LINKS">LINKS</h2>

<p><a href="http://www.grymoire.com/Unix/Sed.html" data-bare-link="true">http://www.grymoire.com/Unix/Sed.html</a></p>


  <ol class='man-decor man-foot man foot'>
    <li class='tl'></li>
    <li class='tc'>May 2011</li>
    <li class='tr'>sed(1)</li>
  </ol>

  </div>
</body>
</html>
