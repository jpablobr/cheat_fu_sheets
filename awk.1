.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "AWK" "1" "April 2011" "" ""
.
.SH "NAME"
\fBawk\fR \- cheat sheet
.
.P
FEATURES
.
.IP "\(bu" 4
Associative array type\.
.
.IP "\(bu" 4
Automatic string, integer, and floating point value types\.
.
.IP "\(bu" 4
C\-style if, while, and do constructs\.
.
.IP "\(bu" 4
For\-each style for construct for iterating over associative arrays\.
.
.IP "\(bu" 4
Arithmetic (+, \-, \fI, /), modulu\-division (%), exponentiation ( increment/decrement (++, \-\-), and assignment shorthand (+=, \-=,\fR=, â€¦) operators\.
.
.IP "\(bu" 4
Array membership operator (expr in array)\.
.
.IP "\(bu" 4
Integral regular expression type and matching operators (str ~ /pattern/)\.
.
.IP "\(bu" 4
Comprehensive builtin function library (a small sample: printf, gsub, split, substr, cos, sin, log, sqrt)\.
.
.IP "\(bu" 4
User defined functions\.
.
.IP "" 0
.
.P
\fBNot bad for 1977\.\fR
.
.SH "EXAMPLES"
Print first field form delimited flat file is a shell pipe:
.
.IP "" 4
.
.nf

cat /etc/passwd | awk \-F: \'{ print $1 }\'
.
.fi
.
.IP "" 0
.
.P
Prints all the usernames from /etc/passwd while avoiding comment lines:
.
.IP "" 4
.
.nf

cat /etc/passwd |
awk \'
    BEGIN     { FS = ":" }
    /^[a\-z_]/ { print $1 }
\'
.
.fi
.
.IP "" 0
.
.P
Associative arrays and for\-in syntax:
.
.IP "" 4
.
.nf

curl \-s http://www\.gutenberg\.org/files/1080/1080\.txt |
awk \'
    BEGIN { FS="[^a\-zA\-Z]+" }

    {
        for (i=1; i<=NF; i++) {
            word = tolower($i)
            words[word]++
        }
    }

    END {
        for (w in words)
             printf("%3d %s\en", words[w], w)
    }
\' |
sort \-rn
.
.fi
.
.IP "" 0
.
.SH "AWK IN RUBY"
The \-n argument causes Ruby to assume a while gets(); \.\.\. end loop around the provided script\. $_ is set to the last line read and the BEGIN and END blocks function exactly as they did in AWK\.
.
.IP "" 4
.
.nf

curl \-s http://www\.gutenberg\.org/files/1080/1080\.txt |
ruby \-ne \'
  BEGIN { $words = Hash\.new(0) }

  $_\.split(/[^a\-zA\-Z]+/)\.each { |word| $words[word\.downcase] += 1 }

  END {
    $words\.each { |word, i| printf "%3d %s\en", i, word }
  }
\' |
sort \-rn
.
.fi
.
.IP "" 0
.
.SH "LINKS"
\fIhttp://tomayko\.com/writings/awkward\-ruby\fR
