.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "AWK" "1" "July 2011" "" ""
.
.SH "NAME"
\fBawk\fR \- HANDY ONE\-LINERS FOR AWK
.
.SH "USAGE:"
.
.SH "Unix: awk \'/pattern/ {print \"$1\"}\' # standard Unix shells"
.
.SH "FILE SPACING:"
.
.SH "double space a file"
.
.nf

awk \'1;{print ""}
awk \'BEGIN{ORS="\en\en"};1\'
.
.fi
.
.SH "double space a file which already has blank lines in it\. Output file"
.
.SH "should contain no more than one blank line between lines of text\."
.
.SH "NOTE: On Unix systems, DOS lines which have only CRLF (\er\en) are"
.
.SH "often treated as non\-blank, and thus \'NF\' alone will return TRUE\."
.
.nf

awk \'NF{print $0 "\en"}\'
.
.fi
.
.SH "triple space a file"
.
.nf

awk \'1;{print "\en"}\'
.
.fi
.
.SH "precede each line by its line number FOR THAT FILE (left alignment)\."
.
.SH "Using a tab (\et) instead of space will preserve margins\."
.
.nf

awk \'{print FNR "\et" $0}\' files*
.
.fi
.
.SH "precede each line by its line number FOR ALL FILES TOGETHER, with tab\."
.
.nf

awk \'{print NR "\et" $0}\' files*
.
.fi
.
.SH "number each line of a file (number on left, right\-aligned)"
.
.SH "Double the percent signs if typing from the DOS command prompt\."
.
.nf

awk \'{printf("%5d : %s\en", NR,$0)}\'
.
.fi
.
.SH "number each line of file, but only print numbers if line is not blank"
.
.SH "Remember caveats about Unix treatment of \er (mentioned above)"
.
.nf

awk \'NF{$0=++a " :" $0};{print}\'
awk \'{print (NF? ++a " :" :"") $0}\'
.
.fi
.
.SH "count lines (emulates \"wc \-l\")"
.
.nf

awk \'END{print NR}\'
.
.fi
.
.SH "print the sums of the fields of every line"
.
.nf

awk \'{s=0; for (i=1; i<=NF; i++) s=s+$i; print s}\'
.
.fi
.
.SH "add all fields in all lines and print the sum"
.
.nf

awk \'{for (i=1; i<=NF; i++) s=s+$i}; END{print s}\'
.
.fi
.
.SH "print every line after replacing each field with its absolute value"
.
.nf

awk \'{for (i=1; i<=NF; i++) if ($i < 0) $i = \-$i; print }\'
awk \'{for (i=1; i<=NF; i++) $i = ($i < 0) ? \-$i : $i; print }\'
.
.fi
.
.SH "print the total number of fields (\"words\") in all lines"
.
.nf

awk \'{ total = total + NF }; END {print total}\' file
.
.fi
.
.SH "print the total number of lines that contain \"Beth\""
.
.nf

awk \'/Beth/{n++}; END {print n+0}\' file
.
.fi
.
.SH "print the largest first field and the line that contains it"
.
.SH "Intended for finding the longest string in field #1"
.
.nf

awk \'$1 > max {max=$1; maxline=$0}; END{ print max, maxline}\'
.
.fi
.
.SH "print the number of fields in each line, followed by the line"
.
.nf

awk \'{ print NF ":" $0 } \'
.
.fi
.
.SH "print the last field of each line"
.
.nf

awk \'{ print $NF }\'
.
.fi
.
.SH "print the last field of the last line"
.
.nf

awk \'{ field = $NF }; END{ print field }\'
.
.fi
.
.SH "print every line with more than 4 fields"
.
.nf

awk \'NF > 4\'
.
.fi
.
.SH "print every line where the value of the last field is > 4"
.
.nf

awk \'$NF > 4\'
.
.fi
.
.SH "IN UNIX ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format"
.
.nf

awk \'{sub(/\er$/,"");print}\'   assumes EACH line ends with Ctrl\-M
.
.fi
.
.SH "IN UNIX ENVIRONMENT: convert Unix newlines (LF) to DOS format"
.
.nf

awk \'{sub(/$/,"\er");print}
.
.fi
.
.SH "IN DOS ENVIRONMENT: convert Unix newlines (LF) to DOS format"
.
.nf

awk 1
.
.fi
.
.SH "IN DOS ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format"
.
.SH "Cannot be done with DOS versions of awk, other than gawk:"
.
.nf

gawk \-v BINMODE="w" \'1\' infile >outfile
.
.fi
.
.SH "Use \"tr\" instead\."
.
.SH "tr \-d \er <var>infile</var>outfile GNU tr version 1\.22 or higher"
.
.SH "delete leading whitespace (spaces, tabs) from front of each line"
.
.SH "aligns all text flush left"
.
.nf

awk \'{sub(/^[ \et]+/, ""); print}\'
.
.fi
.
.SH "delete trailing whitespace (spaces, tabs) from end of each line"
.
.nf

awk \'{sub(/[ \et]+$/, "");print}\'
.
.fi
.
.SH "delete BOTH leading and trailing whitespace from each line"
.
.nf

awk \'{gsub(/^[ \et]+|[ \et]+$/,"");print}\'
awk \'{$1=$1;print}\'           also removes extra space between fields
.
.fi
.
.SH "insert 5 blank spaces at beginning of each line (make page offset)"
.
.nf

awk \'{sub(/^/, "     ");print}\'
.
.fi
.
.SH "align all text flush right on a 79\-column width"
.
.nf

awk \'{printf "%79s\en", $0}\' file*
.
.fi
.
.SH "center all text on a 79\-character width"
.
.nf

awk \'{l=length();s=int((79\-l)/2); printf "%"(s+l)"s\en",$0}\' file*
.
.fi
.
.SH "substitute (find and replace) \"foo\" with \"bar\" on each line"
.
.nf

awk \'{sub(/foo/,"bar");print}\'           replaces only 1st instance
.
.fi
.
.SH "gawk \'{$0=gensub(/foo/,\"bar\",4);print}\' replaces only 4th instance"
.
.nf

awk \'{gsub(/foo/,"bar");print}\'          replaces ALL instances in a line
.
.fi
.
.SH "substitute \"foo\" with \"bar\" ONLY for lines which contain \"baz\""
.
.nf

awk \'/baz/{gsub(/foo/, "bar")};{print}\'
.
.fi
.
.SH "substitute \"foo\" with \"bar\" EXCEPT for lines which contain \"baz\""
.
.nf

awk \'!/baz/{gsub(/foo/, "bar")};{print}\'
.
.fi
.
.SH "change \"scarlet\" or \"ruby\" or \"puce\" to \"red\""
.
.nf

awk \'{gsub(/scarlet|ruby|puce/, "red"); print}\'
.
.fi
.
.SH "reverse order of lines (emulates \"tac\")"
.
.nf

awk \'{a[i++]=$0} END {for (j=i\-1; j>=0;) print a[j\-\-] }\' file*
.
.fi
.
.SH "if a line ends with a backslash, append the next line to it"
.
.SH "(fails if there are multiple lines ending with backslash\.\.\.)"
.
.nf

awk \'/\e\e$/ {sub(/\e\e$/,""); getline t; print $0 t; next}; 1\' file*
.
.fi
.
.SH "print and sort the login names of all users"
.
.nf

awk \-F ":" \'{ print $1 | "sort" }\' /etc/passwd
.
.fi
.
.SH "print the first 2 fields, in opposite order, of every line"
.
.nf

awk \'{print $2, $1}\' file
.
.fi
.
.SH "switch the first 2 fields of every line"
.
.nf

awk \'{temp = $1; $1 = $2; $2 = temp}\' file
.
.fi
.
.SH "print every line, deleting the second field of that line"
.
.nf

awk \'{ $2 = ""; print }\'
.
.fi
.
.SH "print in reverse order the fields of every line"
.
.nf

awk \'{for (i=NF; i>0; i\-\-) printf("%s ",i);printf ("\en")}\' file
.
.fi
.
.SH "remove duplicate, consecutive lines (emulates \"uniq\")"
.
.nf

awk \'a !~ $0; {a=$0}\'
.
.fi
.
.SH "remove duplicate, nonconsecutive lines"
.
.nf

awk \'! a[$0]++\'                     most concise script
awk \'!($0 in a) {a[$0];print}\'      most efficient script
.
.fi
.
.SH "concatenate every 5 lines of input, using a comma separator"
.
.SH "between fields"
.
.nf

awk \'ORS=%NR%5?",":"\en"\' file
.
.fi
.
.SH "print first 10 lines of file (emulates behavior of \"head\")"
.
.nf

awk \'NR < 11\'
.
.fi
.
.SH "print first line of file (emulates \"head \-1\")"
.
.nf

awk \'NR>1{exit};1\'
.
.fi
.
.SH "print the last 2 lines of a file (emulates \"tail \-2\")"
.
.nf

awk \'{y=x "\en" $0; x=$0};END{print y}\'
.
.fi
.
.SH "print the last line of a file (emulates \"tail \-1\")"
.
.nf

awk \'END{print}\'
.
.fi
.
.SH "print only lines which match regular expression (emulates \"grep\")"
.
.nf

awk \'/regex/\'
.
.fi
.
.SH "print only lines which do NOT match regex (emulates \"grep \-v\")"
.
.nf

awk \'!/regex/\'
.
.fi
.
.SH "print the line immediately before a regex, but not the line"
.
.SH "containing the regex"
.
.nf

awk \'/regex/{print x};{x=$0}\'
awk \'/regex/{print (x=="" ? "match on line 1" : x)};{x=$0}\'
.
.fi
.
.SH "print the line immediately after a regex, but not the line"
.
.SH "containing the regex"
.
.nf

awk \'/regex/{getline;print}\'
.
.fi
.
.SH "grep for AAA and BBB and CCC (in any order)"
.
.nf

awk \'/AAA/; /BBB/; /CCC/\'
.
.fi
.
.SH "grep for AAA and BBB and CCC (in that order)"
.
.nf

awk \'/AAA\.*BBB\.*CCC/\'
.
.fi
.
.SH "print only lines of 65 characters or longer"
.
.nf

awk \'length > 64\'
.
.fi
.
.SH "print only lines of less than 65 characters"
.
.nf

awk \'length < 64\'
.
.fi
.
.SH "print section of file from regular expression to end of file"
.
.nf

awk \'/regex/,0\'
awk \'/regex/,EOF\'
.
.fi
.
.SH "print section of file based on line numbers (lines 8\-12, inclusive)"
.
.nf

awk \'NR==8,NR==12\'
.
.fi
.
.SH "print line number 52"
.
.nf

awk \'NR==52\'
awk \'NR==52 {print;exit}\'          more efficient on large files
.
.fi
.
.SH "print section of file between two regular expressions (inclusive)"
.
.nf

awk \'/Iowa/,/Montana/\'             case sensitive
.
.fi
.
.SH "delete ALL blank lines from a file (same as \"grep \'\.\' \")"
.
.nf

awk NF
awk \'/\./\'
.
.fi
.
.SH "REFERECE"
\fIhttp://www\.catonmat\.net/blog/wp\-content/uploads/2008/09/awk1line\.txt\fR
