.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "REGEXP" "1" "July 2011" "" ""
print "success" if subject =~ /regex/
.
.br
result = subject\.gsub(/before/, "after")
.
.br
myarray = mystring\.scan(/delimiter/)
.
.br
.
.SH "EXAMPLES"
.
.SH "Everything before"
.
.nf

    ^\.*?(?=[^\e/]+$)
.
.fi
.
.SH "EVerything after (? in this case)"
.
.nf

    \e?(\.*)
.
.fi
.
.SH "Operators"
\fB/i\fR makes match case insensitive\.
.
.br
\fB/m\fR makes the dot match newlines\.
.
.br
\fB[]\fR range specification (e\.g\., [a\-z] means a letter in the range a to z)
.
.br
\fB\ew\fR letter or digit; same as [0\-9A\-Za\-z]
.
.br
\fB\eW\fR neither letter or digit
.
.br
\fB\es\fR space character; same as [ \et\en\er\ef]
.
.br
\fB\eS\fR non\-space character
.
.br
\fB\ed\fR digit character; same as [0\-9]
.
.br
\fB\eD\fR non\-digit character
.
.br
\fB\eb\fR backspace (0x08) (only if in a range specification)
.
.br
\fB\eb\fR word boundary (if not in a range specification)
.
.br
\fB\eB\fR non\-word boundary
.
.br
\fB*\fR zero or more repetitions of the preceding
.
.br
\fB+\fR one or more repetitions of the preceding
.
.br
\fB{m,n}\fR at least m and at most n repetitions of the preceding
.
.br
\fB?\fR at most one repetition of the preceding; same as {0,1}
.
.br
\fB|\fR either preceding or next expression may match
.
.br
\fB()\fR grouping
.
.br
\fB/o\fR causes any #{\.\.\.} substitutions in a particular regex literal to be performed just once, the first time it is evaluated\. Otherwise, the substitutions will be performed every time the literal generates a Regexp object\.
.
.br
.
.SH "The Anchor Characters: ^ and $"
.
.nf

^A  "A" at the beginning of a line
A$  "A" at the end of a line
A^  "A^" anywhere on a line
$A  "$A" anywhere on a line
^^  "^" at the beginning of a line
$$  "$" at the end of a line
.
.fi
.
.SH "Matching a specific number of sets with { and }"
.
.nf

*            Any line with an asterisk
\e*         Any line with an asterisk
\e\e         Any line with a backslash
^*         Any line starting with an asterisk
^A*        Any line
^A\e*         Any line starting with an "A*"
^AA*         Any line if it starts with one "A"
^AA*B        Any line with one or more "A"\'s followed by a "B"
^A\e{4,8\e}B Any line starting with 4, 5, 6, 7 or 8 "A"\'s followed by a "B"
^A\e{4,\e}B    Any line starting with 4 or more "A"\'s followed by a "B"
^A\e{4\e}B     Any line starting with "AAAAB"
\e{4,8\e}    Any line with "{4,8}"
A{4,8}     Any line with "A{4,8}"
.
.fi
.
.SH "POSIX character sets"
.
.nf

[:alnum:]   Alphanumeric
[:cntrl:]   Control Character
[:lower:]   Lower case character
[:space:]   Whitespace
[:alpha:]   Alphabetic
[:digit:]   Digit
[:print:]   Printable character
[:upper:]   Upper Case Character
[:blank:]   whitespace, tabe, etc\.
[:graph:]   Printable and visible characters
[:punct:]   Puctuation
[:xdigit:]  Extended Digit
.
.fi
.
.SH "Perl Extensions"
.
.nf

 Class  Type    Meaning
\et  Character Set   tab
\en  Character Set   newline
\er  Character Set   return
\ef  Character Set   form
\ea  Character Set   alarm
\ee  Character Set   escape
\e033    Character Set   octal
\ex1B    Character Set   hex
\ec[ Character Set   control
\el  Character Set   lowercase
\eu  Character Set   uppercase
\eL  Character Set   lowercase
\eU  Character Set   uppercase
\eE  Character Set   end
\eQ  Character Set   quote
\ew  Character Set   Match a "word" character
\eW  Character Set   Match a non\-word character
\es  Character Set   Match a whitespace character
\eS  Character Set   Match a non\-whitespace character
\ed  Character Set   Match a digit character
\eD  Character Set   Match a non\-digit character
\eb  Anchor  Match a word boundary
\eB  Anchor  Match a non\-(word boundary)
\eA  Anchor  Match only at beginning of string
\eZ  Anchor  Match only at EOS, or before newline
\ez  Anchor  Match only at end of string
\eG  Anchor  Match only where previous m//g left off
.
.fi
.
.SH "Utility Regular Expression Type"
.
.nf

vi      Basic
sed     Basic
grep      Basic
csplit  Basic
dbx     Basic
dbxtool Basic
more      Basic
ed      Basic
expr      Basic
lex     Basic
pg      Basic
nl      Basic
rdist     Basic
awk     Extended
nawk      Extended
egrep     Extended
EMACS     EMACS Regular Expressions
PERL      PERL Regular Expressions
.
.fi
.
.SH "Extended Regular Expressions"
.
.nf

\&\.   all         Character Set   A single character (except newline)
^   all         Anchor  Beginning of line
$   all         Anchor  End of line
[\.\.\.]           all Character Set   Range of characters
*   all         Modifier    zero or more duplicates
\e<            Basic Anchor  Beginning of word
\e>           Basic Anchor  End of word
\e(\.\.\e)        Basic Backreference   Remembers pattern
\e1\.\.\e9        Basic Reference   Recalls pattern
_+            Extended  Modifier    One or more duplicates
?               Extended    Modifier    Zero or one duplicate
\e{M,N\e}       Extended  Modifier    M to N Duplicates
(\.\.\.|\.\.\.)       Extended    Anchor  Shows alteration
_
\e(\.\.\.\e|\.\.\.\e)    EMACS   Anchor  Shows alteration
\ew            EMACS Character set   Matches a letter in a word
\eW            EMACS Character set   Opposite of \ew
.
.fi
.
.P
Two programs use the extended regular expression: egrep and awk\. With these extensions, those special characters preceded by a backslash no longer have the special meaning: "{" , "}", "<var>", "</var>", "(", ")" as well as the "\edigit"\. There is a very good reason for this, which I will delay explaining to build up suspense\.
.
.P
The character "?" matches 0 or 1 instances of the character set before, and the character "+" matches one or more copies of the character set\. You can\'t use the { and } in the extended regular expressions, but if you could, you might consider the "?" to be the same as "{0,1}" and the "+" to be the same as "{1,}"\.
.
.P
By now, you are wondering why the extended regular expressions is even worth using\. Except for two abbreviations, there are no advantages, and a lot of disadvantages\. Therefore, examples would be useful\.
.
.P
The three important characters in the expanded regular expressions are "(", "|", and ")"\. Together, they let you match a choice of patterns\. As an example, you can egrep to print all From: and Subject: lines from your incoming mail:
.
.P
egrep \' \' /usr/spool/mail/$USER All lines starting with "From:" or "Subject:" will be printed\. There is no easy way to do this with the Basic regular expressions\. You could try " " and hope you don\'t have any lines that start with "Sromeet:"\. Extended expressions don\'t have the "<var>" and "</var>" characters\. You can compensate by using the alternation mechanism\. Matching the word "the" in the beginning, middle, end of a sentence, or end of a line can be done with the extended regular expression:
.
.P
( )the([ There are two choices before the word, a space or the beginining of a line\. After the word, there must be something besides a lower case letter or else the end of the line\. One extra bonus with extended regular expressions is the ability to use the "*," "+," and "?" modifiers after a "(\.\.\.)" grouping\. The following will match "a simple problem," "an easy problem," as well as "a problem"\.
.
.P
egrep "a[n]? (simple|easy)? problem" data I promised to explain why the backslash characters don\'t work in extended regular expressions\. Well, perhaps the "{\.\.\.}" and "<\.\.\.>" could be added to the extended expressions\. These are the newest addition to the regular expression family\. They could be added, but this might confuse people if those characters are added and the "(\.\.\.)" are not\. And there is no way to add that functionality to the extended expressions without changing the current usage\. Do you see why? It\'s quite simple\. If "(" has a special meaning, then "(" must be the ordinary character\. This is the opposite of the Basic regular expressions, where "(" is ordinary, and "(" is special\. The usage of the parentheses is incompatable, and any change could break old programs\.
.
.P
If the extended expression used "( \.\.|\.\.\.)" as regular characters, and "(\.\.\.\e|\.\.\.)" for specifying alternate patterns, then it is possible to have one set of regular expressions that has full functionality\. This is exactly what GNU emacs does, by the way\.
.
.SH "LINKS"
.
.IP "\(bu" 4
\fIhttp://rubular\.com/\fR
.
.IP "\(bu" 4
\fIhttp://www\.grymoire\.com/Unix/Regular\.html\fR
.
.IP "" 0

