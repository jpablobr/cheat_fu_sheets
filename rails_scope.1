.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "SCOPE" "1" "July 2011" "" ""
.
.SH "NAME"
\fBscope\fR \- cheat sheet
.
.SH "Class Methods To The Rescue"
Thanks to arel’s greatness, you can avoid the hassle and just go back to using good old class methods:
.
.IP "" 4
.
.nf

class << self
  def published
    where(:published => true)
  end
end
.
.fi
.
.IP "" 0
.
.P
Remember that relations stay unevaluated – and thus still chainable! – until they’re first used in a non\-arel context\.
.
.P
This also helps to avoid the tedious lambda syntax that was needed for dynamic scopes:
.
.IP "" 4
.
.nf

class << self
  def by_author(author)
    where(:author_id => author\.id)
  end
end
.
.fi
.
.IP "" 0
.
.P
No problems with optional parameters or differences between Ruby versions either – methods are just methods, after all\. So after all, there is just one syntax for one thing again\.
.
.SH "Should I Ditch Scopes Completely?"
If you want to keep some of scopes’ declarative nature, consider just putting them in a module named Scopes and extending the class like so:
.
.IP "" 4
.
.nf

class Post < ActiveRecord::Base
  module Scopes
    def by_author(author)
      where(:author_id => author\.id)
    end
  end
  extend Scopes
end
.
.fi
.
.IP "" 0
.
.P
This way, you keep scopes somehow separate from the rest of your models’ code\.
