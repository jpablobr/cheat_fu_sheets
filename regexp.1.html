<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='content-type' value='text/html;charset=utf8'>
  <meta name='generator' value='Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)'>
  <title>regexp(1) - Regexps(1)</title>
  <style type='text/css' media='all'>
  /* style: man */
  body#manpage {margin:0}
  .mp {max-width:100ex;padding:0 9ex 1ex 4ex}
  .mp p,.mp pre,.mp ul,.mp ol,.mp dl {margin:0 0 20px 0}
  .mp h2 {margin:10px 0 0 0}
  .mp > p,.mp > pre,.mp > ul,.mp > ol,.mp > dl {margin-left:8ex}
  .mp h3 {margin:0 0 0 4ex}
  .mp dt {margin:0;clear:left}
  .mp dt.flush {float:left;width:8ex}
  .mp dd {margin:0 0 0 9ex}
  .mp h1,.mp h2,.mp h3,.mp h4 {clear:left}
  .mp pre {margin-bottom:20px}
  .mp pre+h2,.mp pre+h3 {margin-top:22px}
  .mp h2+pre,.mp h3+pre {margin-top:5px}
  .mp img {display:block;margin:auto}
  .mp h1.man-title {display:none}
  .mp,.mp code,.mp pre,.mp tt,.mp kbd,.mp samp,.mp h3,.mp h4 {font-family:monospace;font-size:14px;line-height:1.42857142857143}
  .mp h2 {font-size:16px;line-height:1.25}
  .mp h1 {font-size:20px;line-height:2}
  .mp {text-align:justify;background:#fff}
  .mp,.mp code,.mp pre,.mp pre code,.mp tt,.mp kbd,.mp samp {color:#131211}
  .mp h1,.mp h2,.mp h3,.mp h4 {color:#030201}
  .mp u {text-decoration:underline}
  .mp code,.mp strong,.mp b {font-weight:bold;color:#131211}
  .mp em,.mp var {font-style:italic;color:#232221;text-decoration:none}
  .mp a,.mp a:link,.mp a:hover,.mp a code,.mp a pre,.mp a tt,.mp a kbd,.mp a samp {color:#0000ff}
  .mp b.man-ref {font-weight:normal;color:#434241}
  .mp pre {padding:0 4ex}
  .mp pre code {font-weight:normal;color:#434241}
  .mp h2+pre,h3+pre {padding-left:0}
  ol.man-decor,ol.man-decor li {margin:3px 0 10px 0;padding:0;float:left;width:33%;list-style-type:none;text-transform:uppercase;color:#999;letter-spacing:1px}
  ol.man-decor {width:100%}
  ol.man-decor li.tl {text-align:left}
  ol.man-decor li.tc {text-align:center;letter-spacing:4px}
  ol.man-decor li.tr {text-align:right;float:right}
  </style>
</head>
<!--
  The following styles are deprecated and will be removed at some point:
  div#man, div#man ol.man, div#man ol.head, div#man ol.man.

  The .man-page, .man-decor, .man-head, .man-foot, .man-title, and
  .man-navigation should be used instead.
-->
<body id='manpage'>
  <div class='mp' id='man'>

  <div class='man-navigation' style='display:none'>
    <a href="#EXAMPLES">EXAMPLES</a>
    <a href="#Everything-before">Everything before</a>
    <a href="#EVerything-after-in-this-case-">EVerything after (? in this case)</a>
    <a href="#Operators">Operators</a>
    <a href="#The-Anchor-Characters-and-">The Anchor Characters: ^ and $</a>
    <a href="#Matching-a-specific-number-of-sets-with-and-">Matching a specific number of sets with { and }</a>
    <a href="#POSIX-character-sets">POSIX character sets</a>
    <a href="#Perl-Extensions">Perl Extensions</a>
    <a href="#Utility-Regular-Expression-Type">Utility  Regular Expression Type</a>
    <a href="#Extended-Regular-Expressions">Extended Regular Expressions</a>
    <a href="#LINKS">LINKS</a>
  </div>

  <ol class='man-decor man-head man head'>
    <li class='tl'>regexp(1)</li>
    <li class='tc'></li>
    <li class='tr'>regexp(1)</li>
  </ol>

  <h1>Regexps(1)</h1>
<p>print "success" if subject =~ /regex/<br />
result = subject.gsub(/before/, "after")<br />
myarray = mystring.scan(/delimiter/)<br /></p>

<h2 id="EXAMPLES">EXAMPLES</h2>

<h2 id="Everything-before">Everything before</h2>

<pre><code>    ^.*?(?=[^\/]+$)
</code></pre>

<h2 id="EVerything-after-in-this-case-">EVerything after (? in this case)</h2>

<pre><code>    \?(.*)
</code></pre>

<h2 id="Operators">Operators</h2>

<p><code>/i   </code> makes match case insensitive.<br />
<code>/m   </code> makes the dot match newlines.<br />
<code>[]     </code> range specification (e.g., [a-z] means a letter in the range a to z)<br />
<code>\w     </code> letter or digit; same as [0-9A-Za-z]<br />
<code>\W     </code> neither letter or digit<br />
<code>\s     </code> space character; same as [ \t\n\r\f]<br />
<code>\S     </code> non-space character<br />
<code>\d     </code> digit character; same as [0-9]<br />
<code>\D     </code> non-digit character<br />
<code>\b     </code> backspace (0x08) (only if in a range specification)<br />
<code>\b     </code> word boundary (if not in a range specification)<br />
<code>\B     </code> non-word boundary<br />
<code>*    </code> zero or more repetitions of the preceding<br />
<code>+    </code> one or more repetitions of the preceding<br />
<code>{m,n}</code>    at least m and at most n repetitions of the preceding<br />
<code>?    </code> at most one repetition of the preceding; same as {0,1}<br />
<code>|    </code> either preceding or next expression may match<br />
<code>()     </code> grouping<br />
<code>/o   </code> causes any #{...} substitutions in a particular regex literal to be performed just once, the first time it is evaluated. Otherwise, the substitutions will be performed every time the literal generates a Regexp object.<br /></p>

<h2 id="The-Anchor-Characters-and-">The Anchor Characters: ^ and $</h2>

<pre><code>^A  "A" at the beginning of a line
A$  "A" at the end of a line
A^  "A^" anywhere on a line
$A  "$A" anywhere on a line
^^  "^" at the beginning of a line
$$  "$" at the end of a line
</code></pre>

<h2 id="Matching-a-specific-number-of-sets-with-and-">Matching a specific number of sets with { and }</h2>

<pre><code>*            Any line with an asterisk
\*         Any line with an asterisk
\\         Any line with a backslash
^*         Any line starting with an asterisk
^A*        Any line
^A\*         Any line starting with an "A*"
^AA*         Any line if it starts with one "A"
^AA*B        Any line with one or more "A"'s followed by a "B"
^A\{4,8\}B Any line starting with 4, 5, 6, 7 or 8 "A"'s followed by a "B"
^A\{4,\}B    Any line starting with 4 or more "A"'s followed by a "B"
^A\{4\}B     Any line starting with "AAAAB"
\{4,8\}    Any line with "{4,8}"
A{4,8}     Any line with "A{4,8}"
</code></pre>

<h2 id="POSIX-character-sets">POSIX character sets</h2>

<pre><code>[:alnum:]   Alphanumeric
[:cntrl:]   Control Character
[:lower:]   Lower case character
[:space:]   Whitespace
[:alpha:]   Alphabetic
[:digit:]   Digit
[:print:]   Printable character
[:upper:]   Upper Case Character
[:blank:]   whitespace, tabe, etc.
[:graph:]   Printable and visible characters
[:punct:]   Puctuation
[:xdigit:]  Extended Digit
</code></pre>

<h2 id="Perl-Extensions">Perl Extensions</h2>

<pre><code> Class  Type    Meaning
\t  Character Set   tab
\n  Character Set   newline
\r  Character Set   return
\f  Character Set   form
\a  Character Set   alarm
\e  Character Set   escape
\033    Character Set   octal
\x1B    Character Set   hex
\c[ Character Set   control
\l  Character Set   lowercase
\u  Character Set   uppercase
\L  Character Set   lowercase
\U  Character Set   uppercase
\E  Character Set   end
\Q  Character Set   quote
\w  Character Set   Match a "word" character
\W  Character Set   Match a non-word character
\s  Character Set   Match a whitespace character
\S  Character Set   Match a non-whitespace character
\d  Character Set   Match a digit character
\D  Character Set   Match a non-digit character
\b  Anchor  Match a word boundary
\B  Anchor  Match a non-(word boundary)
\A  Anchor  Match only at beginning of string
\Z  Anchor  Match only at EOS, or before newline
\z  Anchor  Match only at end of string
\G  Anchor  Match only where previous m//g left off
</code></pre>

<h2 id="Utility-Regular-Expression-Type">Utility  Regular Expression Type</h2>

<pre><code>vi      Basic
sed     Basic
grep      Basic
csplit  Basic
dbx     Basic
dbxtool Basic
more      Basic
ed      Basic
expr      Basic
lex     Basic
pg      Basic
nl      Basic
rdist     Basic
awk     Extended
nawk      Extended
egrep     Extended
EMACS     EMACS Regular Expressions
PERL      PERL Regular Expressions
</code></pre>

<h2 id="Extended-Regular-Expressions">Extended Regular Expressions</h2>

<pre><code>.   all         Character Set   A single character (except newline)
^   all         Anchor  Beginning of line
$   all         Anchor  End of line
[...]           all Character Set   Range of characters
*   all         Modifier    zero or more duplicates
\&lt;            Basic Anchor  Beginning of word
\>           Basic Anchor  End of word
\(..\)        Basic Backreference   Remembers pattern
\1..\9        Basic Reference   Recalls pattern
_+            Extended  Modifier    One or more duplicates
?               Extended    Modifier    Zero or one duplicate
\{M,N\}       Extended  Modifier    M to N Duplicates
(...|...)       Extended    Anchor  Shows alteration
_
\(...\|...\)    EMACS   Anchor  Shows alteration
\w            EMACS Character set   Matches a letter in a word
\W            EMACS Character set   Opposite of \w
</code></pre>

<p>Two programs use the extended regular expression: egrep and awk. With
these extensions, those special characters preceded by a backslash no
longer have the special meaning: "{" , "}", "&lt;var>", "&lt;/var>", "(", ")" as
well as the "\digit". There is a very good reason for this, which I will
delay explaining to build up suspense.</p>

<p>The character "?" matches 0 or 1 instances of the character set before,
and the character "+" matches one or more copies of the character
set. You can't use the { and } in the extended regular expressions,
but if you could, you might consider the "?" to be the same as "{0,1}"
and the "+" to be the same as "{1,}".</p>

<p>By now, you are wondering why the extended regular expressions is even
worth using. Except for two abbreviations, there are no advantages, and
a lot of disadvantages. Therefore, examples would be useful.</p>

<p>The three important characters in the expanded regular expressions are
"(", "|", and ")". Together, they let you match a choice of patterns. As
an example, you can egrep to print all From: and Subject: lines from
your incoming mail:</p>

<p>egrep '<sup>(From|Subject):</sup> ' /usr/spool/mail/$USER All lines starting with
"From:" or "Subject:" will be printed. There is no easy way to do this
with the Basic regular expressions. You could try
"<sup>[FS][ru][ob][mj]e<em>c</em>t*:</sup> " and hope you don't have any lines that start
with "Sromeet:". Extended expressions don't have the "&lt;var>" and "&lt;/var>"
characters. You can compensate by using the alternation
mechanism. Matching the word "the" in the beginning, middle, end of a
sentence, or end of a line can be done with the extended regular
expression:</p>

<p>(<sup>|</sup> )the([<sup>a-z]|$)</sup> There are two choices before the word, a space or the
beginining of a line. After the word, there must be something besides a
lower case letter or else the end of the line. One extra bonus with
extended regular expressions is the ability to use the "*," "+," and "?"
modifiers after a "(...)" grouping. The following will match "a simple
problem," "an easy problem," as well as "a problem".</p>

<p>egrep "a[n]? (simple|easy)? problem" data I promised to explain why the
backslash characters don't work in extended regular expressions. Well,
perhaps the "{...}" and "&lt;...>" could be added to the extended
expressions. These are the newest addition to the regular expression
family. They could be added, but this might confuse people if those
characters are added and the "(...)" are not. And there is no way to
add that functionality to the extended expressions without changing the
current usage. Do you see why? It's quite simple. If "(" has a special
meaning, then "(" must be the ordinary character. This is the opposite
of the Basic regular expressions, where "(" is ordinary, and "(" is
special. The usage of the parentheses is incompatable, and any change
could break old programs.</p>

<p>If the extended expression used "( ..|...)" as regular characters, and
"(...\|...)" for specifying alternate patterns, then it is possible to
have one set of regular expressions that has full functionality. This is
exactly what GNU emacs does, by the way.</p>

<h2 id="LINKS">LINKS</h2>

<ul>
<li><a href="http://rubular.com/" data-bare-link="true">http://rubular.com/</a></li>
<li><a href="http://www.grymoire.com/Unix/Regular.html" data-bare-link="true">http://www.grymoire.com/Unix/Regular.html</a></li>
</ul>



  <ol class='man-decor man-foot man foot'>
    <li class='tl'></li>
    <li class='tc'>July 2011</li>
    <li class='tr'>regexp(1)</li>
  </ol>

  </div>
</body>
</html>
