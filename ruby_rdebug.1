.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "RUBY_RDEBUG" "1" "March 2011" "" ""
General Informations and Key shortcuts for Kent Sibilev\'s great ruby\-debug gem\. http://www\.datanoise\.com/ruby\-debug/, http://rubyforge\.org/projects/ruby\-debug/
.
.P
A reference manual for version 0\.10\.0 is at http://bashdb\.sf\.net/ruby\-debug\.html
.
.SH "Installation"
.
.nf

gem install ruby\-debug
.
.fi
.
.SH "Usage"
.
.nf

rdebug [options] <script\.rb> \-\- <script\.rb parameters>
.
.fi
.
.SH "startup settings:"
rdebug reads its configuration file at startup\. create a file ~/\.rdebugrc with this content:
.
.IP "" 4
.
.nf

set autolist
set autoeval
set autoreload
.
.fi
.
.IP "" 0
.
.P
after starting rdebug like:
.
.IP "" 4
.
.nf

rdebug script/server
.
.fi
.
.IP "" 0
.
.P
enter \fBc\fR and \fBreturn\fR for starting up rdebug finally\.
.
.SH "Most important commands:"
\fBr\fR[eload], \fBn\fR[ext], \fBc\fR[ont]
.
.SH "Commands (available as \'help <var>command\-name</var>\' in active debug mode)"
.
.SH "backtrace (alias for where)"
.
.nf

(rdb:1) bt|backtrace
.
.fi
.
.SH "break"
.
.nf

(rdb:1) b[reak] file:line [if expr]
(rdb:1) b[reak] class(\.|#)method [if expr]
          set breakpoint to some position, (optionally) if expr == true
.
.fi
.
.SH "Before version 0\.10\.0:"
.
.nf

(rdb:1) b[reak]    list breakpoints
0\.10\.0 or later:
(rdb:1) info b[reak]
.
.fi
.
.SH "catch"
.
.nf

(rdb:1) cat[ch]                 (show catchpoint)
(rdb:1) cat[ch] <an Exception>  (set catchpoint to an exception)
.
.fi
.
.SH "cont"
.
.nf

(rdb:1) c[ont][ nnn] (run until program ends or hits breakpoint or reaches line nnn)
.
.fi
.
.SH "delete"
.
.nf

(rdb:1) del[ete][ nnn] (delete some or all breakpoints)
.
.fi
.
.SH "disable"
.
.nf

(rdb:1) disable BPT\-NUM \- disable given breakpoint number
.
.fi
.
.SH "display"
.
.nf

(rdb:1) disp[lay] <expression> (add expression into display expression list)
(rdb:1) disp[lay]              (display expression list)
.
.fi
.
.SH "down"
.
.nf

(rdb:1) down[count] (move to lower frame)
.
.fi
.
.SH "enable"
.
.nf

(rdb:1) enable BPT\-NUM \- enable given breakpoint number
.
.fi
.
.SH "eval"
.
.nf

(rdb:1) e[val] expression evaluate expression and print its value, alias for p\.
                * NOTE \- to turn on autoeval, use \'set autoeval\'
.
.fi
.
.SH "exit"
.
.nf

(rdb:1) q[uit]  exit from debugger,
(rdb:1) exit    alias to quit
.
.fi
.
.SH "finish"
.
.nf

(rdb:1) fin[ish] return to outer frame
.
.fi
.
.SH "frame"
.
.nf

(rdb:1) f[rame] frame\-number
  Move the current frame to the specified frame number\.
  A negative number indicates position from the other end\.
  So \'frame \-1\' moves to the oldest frame, and \'frame 0\' moves to
  the newest frame\.
.
.fi
.
.SH "help"
.
.nf

(rdb:1) h[elp]          print help
(rdb:1) h[elp] command  print help on command
.
.fi
.
.SH "irb"
.
.nf

(rdb:1) irb starts an IRB session\. (EXPERIMENTAL)
.
.fi
.
.SH "list"
.
.nf

(rdb:1) l[ist]          list forward
(rdb:1) l[ist] \-        list backward
(rdb:1) l[ist] =        list current line
(rdb:1) l[ist] nn\-mm    list given lines
.
.fi
.
.SH "method"
.
.nf

(rdb:1) m[ethod] i[nstance] <obj>       show methods of object
(rdb:1) m[ethod] <class|module>         show instance methods of class or module
.
.fi
.
.SH "next"
.
.nf

(rdb:1) n[ext][+][ nnn] step over once or nnn times,
              \'+\' forces to move to another line
.
.fi
.
.SH "p"
.
.nf

(rdb:1)  p expression    evaluate expression and print its value
.
.fi
.
.SH "pp"
.
.nf

(rdb:1) pp expression   evaluate expression and pretty\-print its value
.
.fi
.
.SH "ps"
.
.nf

(rdb: 1) ps array \- print array in columnized sorted order (e\.g\. "ps Kernel\.methods")
.
.fi
.
.SH "putl"
.
.nf

(rdb: 1) putl array \- print array in columnized order
.
.fi
.
.SH "quit"
.
.nf

(rdb:1) q[uit]  exit from debugger,
(rdb:1) exit    alias to quit
.
.fi
.
.SH "reload"
.
.nf

(rdb:1) r[eload]        forces source code reloading
.
.fi
.
.SH "restart"
.
.nf

(rdb:1) restart|R [args]
.
.fi
.
.P
Restart the program\. This is is a re\-exec \- all debugger state is lost\. If command arguments are passed those are used\.
.
.SH "save"
.
.nf

(rdb:1) save [FILE]      saves current breakpoints and catchpoint as a script file
.
.fi
.
.SH "Before 0\.10\.0:"
.
.nf

(rdb:1) script FILE     executes a script file
.
.fi
.
.SH "After 0\.10\.0 (to be gdb compatible):"
.
.nf

(rdb:1) source FILE     executes a script file
.
.fi
.
.SH "set"
.
.nf

(rdb:1) set <setting>
.
.fi
.
.SH "where <var>setting</var>:"
.
.nf

args           \- argument list to give program being debugged when restarted
autolist       \- execute \'list\' command on every breakpoint
autoeval       \- evaluate every unrecognized command
autoreload     \- enables automatic source code reloading
autoirb        \- debugger invokes IRB on every stop
listsize       \- number of source lines to list by default
trace          \- display stack trace when \'eval\' raises exception
framefullpath  \- frame will display full file names
frameclassname \- frame will display class names
forcestep      \- make sure \'next/step\' commands always move to a new line
width          \- number of characters the debugger things are in aline
.
.fi
.
.P
To disable setting, use \'no\' prefix, like \'noautolist\' or "off" as in
.
.IP "" 4
.
.nf

"autolist off"
.
.fi
.
.IP "" 0
.
.SH "step"
.
.nf

(rdb:1) s[tep][ nnn]    step (into methods) once or nnn times
.
.fi
.
.SH "thread"
.
.nf

(rdb:1) th[read] l[ist]                 list all threads
(rdb:1) th[read] [sw[itch]] <nnn>       switch thread context to nnn
(rdb:1) th[read] stop <nnn>             stop thread nnn
(rdb:1) th[read] c[ur[rent]]            show current thread
(rdb:1) th[read] resume <nnn>           resume thread nnn
.
.fi
.
.SH "trace"
.
.nf

(rdb:1) tr[ace] (on|off)        set trace mode of current thread
(rdb:1) tr[ace] (on|off) all    set trace mode of all threads
.
.fi
.
.SH "undisplay"
.
.nf

(rdb:1) undisp[lay][ nnn]       delete one particular or all display expressions
.
.fi
.
.SH "up"
.
.nf

(rdb:1) up[count]       move to higher frame
.
.fi
.
.SH "var"
.
.nf

(rdb:1) v[ar] const <object>            show constants of object
(rdb:1) v[ar] g[lobal]                  show global variables
(rdb:1) v[ar] i[nstance] <object>       show instance variables of object
(rdb:1) v[ar] l[ocal]                   show local variables
.
.fi
.
.P
Before 10\.0 const can be abbreviated "c", after 10\.0 or later you need "co" because there is also "var class
.
.SH "where"
.
.nf

(rdb:1) w[here] display frames
.
.fi

