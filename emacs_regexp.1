.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "EMACS" "1" "July 2011" "" ""
.
.SH "NAME"
\fBemacs\fR \- Regexp
.
.P
In emacs regex, the parenthesis characters \fB() are literal\fR\. If you want to capture a pattern, you need to escape the paren like this: \fB\e(myPattern\e)\fR\.
.
.P
The special characters are \'$ The character \']\' is special if it ends a character alternative (see later)\. The character \'\-\' is special inside a character alternative\. Any other character appearing in a regular expression is ordinary, unless a \'\e\' precedes it\.
.
.SH "Pattern Matches"
.
.nf

\&\.                any single character
\e\.             one period
[0\-9]+         sequence of digits
[A\-Za\-z]+        sequence of letters
[\-A\-Za\-z0\-9]+    sequence of letter, digit, hyphen
[_A\-Za\-z0\-9]+    sequence of letter, digit, underscore
[\-_A\-Za\-z0\-9]+ sequence of letter, digit, hyphen, underscore
[[:blank:]]+     sequence of tabs and spaces
[[:upper:]]+     sequence of cap letters
[[:lower:]]+     sequence of lowercase letters
"\e([^"]+?\e)"     capture text between double quotes (non\-greedy)
(\e([^)]+?\e))     capture text between parenthesis (non\-greedy)
“\e([^”]+?\e)”   capture text between curly double quotes (non\-greedy; unicode char)
+   means match  previous pattern 1 or more times
*   means match  previous pattern 0 or more times
?   means match  previous pattern 0 or 1 time
.
.fi
.
.P
\fB\.\fR (Period) is a special character that matches any single character except a newline\. For example, the regular expressions \'a\.b\' matches any three\-character string that begins with \'a\' and ends with \'b\'\.
.
.P
\fB*\fR is not a construct by itself; it is a postfix operator that means to match the preceding regular expression repetitively any number of times, as many times as possible\. Thus, \'o*\' matches any number of \'o\'s, including no \'o\'s\.
.
.P
\fB+\fR is a postfix operator, similar to \'\fI\' except that it must match the preceding expression at least once\. Thus, \'ca+r\' matches the strings \'car\' and \'caaaar\' but not the string \'cr\', whereas \'ca\fRr\' matches all three strings\.
.
.P
\fB?\fR is a postfix operator, similar to \'*\' except that it can match the preceding expression either once or not at all\. Thus, \'ca?r\' matches \'car\' or \'cr\', and nothing else\.
.
.P
\fB*?, +?, ??\fR are non\-greedy variants of the operators above\. The normal operators \'\fI\', \'+\', \'?\' match as much as they can, as long as the overall regexp can still match\. With a following \'?\', they will match as little as possible\. Thus, both \'ab\fR\' and \'ab\fI?\' can match the string \'a\' and the string \'abbbb\'; but if you try to match them both against the text \'abbb\', \'ab\fR\' will match it all (the longest valid match), while \'ab*?\' will match just \'a\' (the shortest valid match)\.
.
.P
\fB\e{n\e}\fR is a postfix operator specifying n repetitions—that is, the preceding regular expression must match exactly n times in a row\. For example, \'x{4}\' matches the string \'xxxx\' and nothing else\.
.
.P
\fB\e{n,m\e}\fR is a postfix operator specifying between n and m repetitions—that is, the preceding regular expression must match at least n times, but no more than m times\. If m is omitted, then there is no upper limit, but the preceding regular expression must match at least n times\. \fB\'\e{0,1\e}\' is equivalent to \'?\'\.\fR \fB\'\e{0,\e}\' is equivalent to \'*\'\.\fR \fB\'\e{1,\e}\' is equivalent to \'+\'\.\fR
.
.P
\fB[ \.\.\. ]\fR Is a character set, beginning with \'[\' and terminated by \']\'\.
.
.P
In the simplest case, the characters between the two brackets are what this set can match\. Thus, \'[ad]\' matches either one \'a\' or one \'d\', and \'[ad]\fI\' matches any string composed of just \'a\'s and \'d\'s (including the empty string)\. It follows that \'c[ad]\fRr\' matches \'cr\', \'car\', \'cdr\', \'caddaar\', etc\.
.
.P
You can also include certain special character classes in a character set\. A \'[:\' and balancing \':]\' enclose a character class inside a character alternative\. For instance, \'[[:alnum:]]\' matches any letter or digit\. See Char Classes, for a list of character classes\.
.
.P
To include a \']\' in a character set, you must make it the first character\. For example, \'[]a]\' matches \']\' or \'a\'\. To include a \'\-\', write \'\-\' as the first or last character of the set, or put it after a range\. Thus, \'[]\-]\' matches both \']\' and \'\-\'\.
.
.P
\fB[^ \.\.\. ]\fR \'[ begins a complemented character set, which matches any character except the ones specified\. Thus, \'[ matches all characters except ASCII letters and digits\. \' is not special in a character set unless it is the first character\. The character following the \' is treated as if it were first (in other words, \'\-\' and \']\' are not special there)\.
.
.P
\fB^\fR is a special character that matches the empty string, but only at the beginning of a line in the text being matched\. Otherwise it fails to match anything\. Thus, \' matches a \'foo\' that occurs at the beginning of a line\.
.
.P
\fB$\fR is similar to \' but matches only at the end of a line\. Thus, \'x+$\' matches a string of one \'x\' or more at the end of a line\.
.
.P
\fB\e\fR Two functions: quotes the special characters (including \'\e\'), and it introduces additional special constructs\. Because \'\e\' quotes special characters, \'\e$\' is a regular expression that matches only \'$\', and \'[\' is a regular expression that matches only \'[\', and so on\.
.
.SH "re\-builder"
Emacs has a interactive regex mode\. It show matches as you type\. To go into the mode, call \fBregexp\-builder\fR\.
.
.SH "Double Backslash in Lisp Code"
In a lisp regex function that takes a regex string (e\.g\. “search\-forward\-regexp”), you will need to use double backslash\. This is because, in elisp string, a backslash needs to be prefixed with a backslash, then, this interpreted string is passed to emacs\'s regex engine\.
.
.P
For example, suppose you have this text:
.
.IP "" 4
.
.nf

Sin[x] + Sin[y]
.
.fi
.
.IP "" 0
.
.P
and you need to capture the 「x」 or 「y」\. You can use:
.
.IP "" 4
.
.nf

(search\-backward\-regexp "\e\e(\e\e[[a\-z]\e\e]\e\e)")
.
.fi
.
.IP "" 0
.
.P
The regex engine really just got:
.
.IP "" 4
.
.nf

\e(\e[[a\-z]\e]\e)
.
.fi
.
.IP "" 0
.
.SH "Differences from Perl\'s Regex"
If you are familiar with Perl\'s regex, here are some practical major differences\.
.
.P
Parenthesis is literal in emacs\'s regex\. Use (pattern) to capture instead\.
.
.P
Do not use [A\-z], as its meaning is currently ambiguous\. Use [A\-Za\-z]\.
.
.P
Character classes like /d, /w, /s does not work\. Use [[:digit:]], [[:word:]], [[:space:]] instead\. For example, perl\'s /d+ for one or more digits is emacs\'s [[:digit:]]+\. (Yes, you need double brackets)
.
.P
When using interactive commands for find ＆ replace, emacs won\'t understand \et, \en\. To enter a literal Tab, press 【Ctrl+q Tab】\. To match a new line, press 【Ctrl+q Ctrl+j】\. (For explanation, see: Emacs\'s Key Notations Explained (/r, ^M, C\-m, RET, \fIreturn\fR, M\-, meta)) In elisp string, you can use \et, \en and no need to double the backslash\.
.
.P
When doing find ＆ replace in a buffer, the line ending char is always represented by \en (Line Feed; ASCII 10)\. You do not need to worry whether the file has unix style line ending or Windows or Mac\. Also, you should NOT change a file\'s eol style by doing find ＆ replace\. (See: Emacs Line Return and Windows, Unix, Mac, All That ^M ^J ^L\.)
.
.SH "REFERENCES"
.
.IP "\(bu" 4
\fIhttp://xahlee\.org/emacs/emacs_regex\.html\fR
.
.IP "" 0

