<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='content-type' value='text/html;charset=utf8'>
  <meta name='generator' value='Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)'>
  <title>collectiveidea(1) - cheat sheet</title>
  <style type='text/css' media='all'>
  /* style: man */
  body#manpage {margin:0}
  .mp {max-width:100ex;padding:0 9ex 1ex 4ex}
  .mp p,.mp pre,.mp ul,.mp ol,.mp dl {margin:0 0 20px 0}
  .mp h2 {margin:10px 0 0 0}
  .mp > p,.mp > pre,.mp > ul,.mp > ol,.mp > dl {margin-left:8ex}
  .mp h3 {margin:0 0 0 4ex}
  .mp dt {margin:0;clear:left}
  .mp dt.flush {float:left;width:8ex}
  .mp dd {margin:0 0 0 9ex}
  .mp h1,.mp h2,.mp h3,.mp h4 {clear:left}
  .mp pre {margin-bottom:20px}
  .mp pre+h2,.mp pre+h3 {margin-top:22px}
  .mp h2+pre,.mp h3+pre {margin-top:5px}
  .mp img {display:block;margin:auto}
  .mp h1.man-title {display:none}
  .mp,.mp code,.mp pre,.mp tt,.mp kbd,.mp samp,.mp h3,.mp h4 {font-family:monospace;font-size:14px;line-height:1.42857142857143}
  .mp h2 {font-size:16px;line-height:1.25}
  .mp h1 {font-size:20px;line-height:2}
  .mp {text-align:justify;background:#fff}
  .mp,.mp code,.mp pre,.mp pre code,.mp tt,.mp kbd,.mp samp {color:#131211}
  .mp h1,.mp h2,.mp h3,.mp h4 {color:#030201}
  .mp u {text-decoration:underline}
  .mp code,.mp strong,.mp b {font-weight:bold;color:#131211}
  .mp em,.mp var {font-style:italic;color:#232221;text-decoration:none}
  .mp a,.mp a:link,.mp a:hover,.mp a code,.mp a pre,.mp a tt,.mp a kbd,.mp a samp {color:#0000ff}
  .mp b.man-ref {font-weight:normal;color:#434241}
  .mp pre {padding:0 4ex}
  .mp pre code {font-weight:normal;color:#434241}
  .mp h2+pre,h3+pre {padding-left:0}
  ol.man-decor,ol.man-decor li {margin:3px 0 10px 0;padding:0;float:left;width:33%;list-style-type:none;text-transform:uppercase;color:#999;letter-spacing:1px}
  ol.man-decor {width:100%}
  ol.man-decor li.tl {text-align:left}
  ol.man-decor li.tc {text-align:center;letter-spacing:4px}
  ol.man-decor li.tr {text-align:right;float:right}
  </style>
</head>
<!--
  The following styles are deprecated and will be removed at some point:
  div#man, div#man ol.man, div#man ol.head, div#man ol.man.

  The .man-page, .man-decor, .man-head, .man-foot, .man-title, and
  .man-navigation should be used instead.
-->
<body id='manpage'>
  <div class='mp' id='man'>

  <div class='man-navigation' style='display:none'>
    <a href="#NAME">NAME</a>
    <a href="#Installation">Installation</a>
    <a href="#Backends">Backends</a>
    <a href="#without-delayed_job">without delayed_job</a>
    <a href="#with-delayed_job">with delayed_job</a>
    <a href="#Running-Jobs">Running Jobs</a>
    <a href="#Custom-Jobs">Custom Jobs</a>
    <a href="#Hooks">Hooks</a>
    <a href="#Gory-Details">Gory Details</a>
    <a href="#Cleaning-up">Cleaning up</a>
    <a href="#Basic-test">Basic test</a>
    <a href="#LINKS">LINKS</a>
  </div>

  <ol class='man-decor man-head man head'>
    <li class='tl'>collectiveidea(1)</li>
    <li class='tc'></li>
    <li class='tr'>collectiveidea(1)</li>
  </ol>

  <h2 id="NAME">NAME</h2>
<p class="man-name">
  <code>collectiveidea</code> - <span class="man-whatis">cheat sheet</span>
</p>

<h2 id="Installation">Installation</h2>

<p>To install, add delayed_job to your Gemfile and run <code>bundle install</code>:</p>

<pre><code>gem 'delayed_job', :git =&gt; 'https://github.com/collectiveidea/delayed_job.git'
</code></pre>

<p>After delayed_job is installed, you will need to setup the backend.</p>

<h2 id="Backends">Backends</h2>

<p>delayed_job supports multiple backends for storing the job queue. See the wiki for other backends besides Active Record.</p>

<p>The default is Active Record, which requires a jobs table.</p>

<pre><code>script/rails generate delayed_job
rake db:migrate
</code></pre>

<h2 id="without-delayed_job">without delayed_job</h2>

<p>@user.activate!(@device)</p>

<h2 id="with-delayed_job">with delayed_job</h2>

<p>@user.delay.activate!(@device)</p>

<p>If a method should always be run in the background, you can call
@#handle_asynchronously@ after the method declaration:</p>

<pre><code>class Device
  def deliver
    # long running method
  end
  handle_asynchronously :deliver
end

device = Device.new
device.deliver
</code></pre>

<p>handle_asynchronously can take as options anything you can pass to
delay. In addition the values can be Proc objects allowing call time
evaluation of the value. For some examples:</p>

<pre><code>class LongTasks
  def send_mailer
    # Some other code
  end
  handle_asynchronously :send_mailer, :priority =&gt; 20

  def in_the_future
    # Some other code
  end
  # 5.minutes.from_now will be evaluated when in_the_future is called
  handle_asynchronously :in_the_future, :run_at =&gt; Proc.new { 5.minutes.from_now }

  def self.when_to_run
    2.hours.from_now
  end

  def call_a_class_method
    # Some other code
  end
  handle_asynchronously :call_a_class_method, :run_at =&gt; Proc.new { when_to_run }

  attr_reader :how_important

  def call_an_instance_method
    # Some other code
  end
  handle_asynchronously :call_an_instance_method, :priority =&gt; Proc.new {|i| i.how_important }
end
</code></pre>

<h2 id="Running-Jobs">Running Jobs</h2>

<p>@script/delayed_job@ can be used to manage a background process which
will start working off jobs.  Make sure you've run <code>script/generate
delayed_job</code>.</p>

<pre><code>RAILS_ENV=production script/delayed_job start
RAILS_ENV=production script/delayed_job stop

Runs two workers in separate processes.
RAILS_ENV=production script/delayed_job -n 2 start
RAILS_ENV=production script/delayed_job stop
</code></pre>

<p>Workers can be running on any computer, as long as they have access to
the database and their clock is in sync. Keep in mind that each worker
will check the database at least every 5 seconds.</p>

<p>You can also invoke @rake jobs:work@ which will start working off
jobs. You can cancel the rake task with @CTRL-C@.</p>

<h2 id="Custom-Jobs">Custom Jobs</h2>

<p>Jobs are simple ruby objects with a method called perform. Any object
which responds to perform can be stuffed into the jobs table. Job
objects are serialized to yaml so that they can later be resurrected by
the job runner.</p>

<pre><code>class NewsletterJob &lt; Struct.new(:text, :emails)
  def perform
    emails.each { |e| NewsletterMailer.deliver_text_to_email(text, e) }
  end
end

Delayed::Job.enqueue NewsletterJob.new('lorem ipsum...', Customers.find(:all).collect(&amp;:email))
</code></pre>

<h2 id="Hooks">Hooks</h2>

<p>You can define hooks on your job that will be called at different stages in the process:</p>

<pre><code>class ParanoidNewsletterJob &lt; NewsletterJob
  def enqueue(job)
    record_stat 'newsletter_job/enqueue'
  end

  def perform
    emails.each { |e| NewsletterMailer.deliver_text_to_email(text, e) }
  end

  def before(job)
    record_stat 'newsletter_job/start'
  end

  def after(job)
    record_stat 'newsletter_job/after'
  end

  def success(job)
    record_stat 'newsletter_job/success'
  end

  def error(job, exception)
    notify_hoptoad(exception)
  end

  def failure
    page_sysadmin_in_the_middle_of_the_night
  end
end
</code></pre>

<h2 id="Gory-Details">Gory Details</h2>

<p>The library evolves around a delayed_jobs table which looks as follows:</p>

<pre><code>create_table :delayed_jobs, :force =&gt; true do |table|
  table.integer  :priority, :default =&gt; 0      # Allows some jobs to jump to the front of the queue
  table.integer  :attempts, :default =&gt; 0      # Provides for retries, but still fail eventually.
  table.text     :handler                      # YAML-encoded string of the object that will do work
  table.text   :last_error                   # reason for last failure (See Note below)
  table.datetime :run_at                       # When to run. Could be Time.zone.now for immediately, or sometime in the future.
  table.datetime :locked_at                    # Set when a client is working on this object
  table.datetime :failed_at                    # Set when all retries have failed (actually, by default, the record is deleted instead)
  table.string   :locked_by                    # Who is working on this object (if locked)
  table.timestamps
end
</code></pre>

<p>It is possible to disable delayed jobs for testing purposes. Set
Delayed::Worker.delay_jobs = false to execute all jobs realtime.</p>

<p>Here is an example of changing job parameters in Rails:</p>

<pre><code># config/initializers/delayed_job_config.rb
Delayed::Worker.destroy_failed_jobs = false
Delayed::Worker.sleep_delay = 60
Delayed::Worker.max_attempts = 3
Delayed::Worker.max_run_time = 5.minutes
Delayed::Worker.delay_jobs = !Rails.env.test?
</code></pre>

<h2 id="Cleaning-up">Cleaning up</h2>

<p>You can invoke @rake jobs:clear@ to delete all jobs in the queue.</p>

<h2 id="Basic-test">Basic test</h2>

<pre><code>gem 'delayed_job', :git =&gt; 'https://github.com/collectiveidea/delayed_job.git'

class Page &lt; ActiveRecord::Base
  def puts_test
    puts '&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;testing delayed job&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;'
  end
  handle_asynchronously :puts_test, :run_at =&gt; Proc.new { 1.minutes.from_now }
end

class PagesController &lt; ApplicationController
  def show
    @page = Page.find(params[:id]
    @page.puts_test
  end
end
</code></pre>

<p>run in the terminal:</p>

<pre><code>rake jobs:work
rails s
rails c
Delayed::Job
</code></pre>

<p>load a page!</p>

<h2 id="LINKS">LINKS</h2>

<p><a href="https://github.com/collectiveidea/delayed_job" data-bare-link="true">https://github.com/collectiveidea/delayed_job</a></p>


  <ol class='man-decor man-foot man foot'>
    <li class='tl'></li>
    <li class='tc'>July 2011</li>
    <li class='tr'>collectiveidea(1)</li>
  </ol>

  </div>
</body>
</html>
